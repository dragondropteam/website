<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"phaser_objects.js.html":{"id":"phaser_objects.js.html","title":"Source: phaser_objects.js","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Source: phaser_objects.js /** * @namespace Sprite/Image */ //region SPRITE/IMAGE /** * Create an image to be used in the game. * @method create_image * @param tag {String} the tag that defines the image * @param source {String} the file path of the image * @returns {} * &lt;pre&gt;&lt;code&gt; * game.load.image(tag, source); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['create_image'] = function (block) { const tag = Blockly.JavaScript.valueToCode(block, 'TAG', Blockly.JavaScript.ORDER_NONE); const source = Blockly.JavaScript.valueToCode(block, 'SRC', Blockly.JavaScript.ORDER_NONE); return `game.load.image(${tag}, ${source});\\n`; }; /** * Create an atlas image to be used in the game. * @method addspritewithatlas * @param tag {String} the tag that defines the image * @param source {String} the file path of the image * @param xml {String} the file path of the xml file * @returns {} * &lt;pre&gt;&lt;code&gt; * game.load.atlasXML(tag, source, xml); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['addspritewithatlas'] = function (block) { const value_tag = Blockly.JavaScript.valueToCode(block, 'tag', Blockly.JavaScript.ORDER_ATOMIC); const value_text_source = Blockly.JavaScript.valueToCode(block, 'text_source', Blockly.JavaScript.ORDER_ATOMIC); const value_text_xmlsource = Blockly.JavaScript.valueToCode(block, 'text_xmlsource', Blockly.JavaScript.ORDER_ATOMIC); return `game.load.atlasXML(${value_tag}, ${value_text_source}, ${value_text_xmlsource})\\n`; }; /** * Create a sprite based on an atlas image. * @method imagesubtextureatlas * @param x {Number} x position of the sprite * @param y {Number} y position of the sprite * @param tag {String} the tag of the image to use for the sprite * @param id {String} the id of the xml texture to use for the sprite * @returns {} * &lt;pre&gt;&lt;code&gt; * game.add.sprite(x, y, tag, id); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['imagesubtextureatlas'] = function (block) { const value_x = Blockly.JavaScript.valueToCode(block, 'x', Blockly.JavaScript.ORDER_ATOMIC); const value_y = Blockly.JavaScript.valueToCode(block, 'y', Blockly.JavaScript.ORDER_ATOMIC); const value_spritesource = Blockly.JavaScript.valueToCode(block, 'spritesource', Blockly.JavaScript.ORDER_ATOMIC); const value_xmlsubtexture = Blockly.JavaScript.valueToCode(block, 'xmlsubtexture', Blockly.JavaScript.ORDER_ATOMIC); return [`game.add.sprite(${value_x}, ${value_y}, ${value_spritesource}, ${value_xmlsubtexture} )`, Blockly.JavaScript.ORDER_NONE]; }; /** * Create a sprite based on an image. * @method add_image * @param x {Number} x position of the sprite * @param y {Number} y position of the sprite * @param tag {String} the tag of the image to use for the sprite * @returns {} * &lt;pre&gt;&lt;code&gt; * game.add.sprite(x, y, tag); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['add_image'] = function (block) { const x_pos = Blockly.JavaScript.valueToCode(block, 'X_POS', Blockly.JavaScript.ORDER_ATOMIC); const y_pos = Blockly.JavaScript.valueToCode(block, 'Y_POS', Blockly.JavaScript.ORDER_ATOMIC); const tag = Blockly.JavaScript.valueToCode(block, 'TAG', Blockly.JavaScript.ORDER_ATOMIC); return [`game.add.sprite(${x_pos}, ${y_pos}, ${tag})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * @deprecated Use add_animation_vi instead * Add an animation to a sprite object. * @method add_animation * @param object {Sprite} sprite to apply the animation to * @param name {String} name of the tag for the animation * @param frames array of numbers or strings that correspond to frames to add to the animation * @param fps {Number} the speed the animation should play * @param loop {Boolean} whether or not the animation should loop or play once * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.add(name, frames, fps, loop); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['add_animation'] = function (block) { const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('object'), Blockly.Variables.NAME_TYPE); const text_name = block.getFieldValue('NAME'); const value_frames = Blockly.JavaScript.valueToCode(block, 'FRAMES', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const number_fps = block.getFieldValue('FPS'); const checkbox_loop = block.getFieldValue('LOOP') == 'TRUE'; return `${variable_object}.animations.add('${text_name}', ${value_frames}, ${number_fps}, ${checkbox_loop});\\n`; }; /** * Add an animation to a sprite object. * @ignore * @method add_animation_vi * @param object {Sprite} sprite to apply the animation to * @param name {String} name of the tag for the animation * @param frames array of numbers or strings that correspond to frames to add to the animation * @param fps {Number} the speed the animation should play * @param loop {Boolean} whether or not the animation should loop or play once * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.add(name, frames, fps, loop); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ // These blocks move towards using value input verus variable fields, this allows the students to for example loop through // a list of objects they want an animation to start playing on Blockly.JavaScript['add_animation_vi'] = function (block) { const variable_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const text_name = block.getFieldValue('NAME'); const value_frames = Blockly.JavaScript.valueToCode(block, 'FRAMES', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const number_fps = block.getFieldValue('FPS'); const checkbox_loop = block.getFieldValue('LOOP') == 'TRUE'; return `${variable_object}.animations.add('${text_name}', ${value_frames}, ${number_fps}, ${checkbox_loop});\\n`; }; /** * Create a sprite sheet from an image. * @method create_sprite_sheet * @param tag {String} the tag that defines the image * @param source {String} the file path of the image * @param width {Number} the width of each frame * @param height {Number} the height of each frame * @returns {} * &lt;pre&gt;&lt;code&gt; * game.load.spritesheet(tag, source, width, height); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['create_sprite_sheet'] = function (block) { const tag = Blockly.JavaScript.valueToCode(block, 'TAG', Blockly.JavaScript.ORDER_ATOMIC); const source = Blockly.JavaScript.valueToCode(block, 'SRC', Blockly.JavaScript.ORDER_NONE); const number_frame_width = block.getFieldValue('FRAME_WIDTH'); const number_frame_height = block.getFieldValue('FRAME_HEIGHT'); return `game.load.spritesheet(${tag}, ${source}, ${number_frame_width}, ${number_frame_height});\\n`; }; /** * @deprecated * Adds a child to the given object. * @method add_child * @param object the object to add a child to * @param child the child to add to the object * @returns {} * &lt;pre&gt;&lt;code&gt; * object.addChild(child); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['add_child'] = function (block) { const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); const value_child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); return `${variable_object}.addChild(${value_child});\\n`; }; /** * Adds a child to the given object. * @method add_child_vi * @param object the object to add a child to * @param child the child to add to the object * @returns {} * &lt;pre&gt;&lt;code&gt; * object.addChild(child); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['add_child_vi'] = function (block) { const variable_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); return `${variable_object}.addChild(${value_child});\\n`; }; /** * @deprecated * Adds a child to the given object at the given index. * @method add_child_at * @param object the object to add a child to * @param child the child to add to the object * @param index {Number} the index to add the child to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.addChildAt(child, index); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['add_child_at'] = function (block) { const value_child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); const value_index = Blockly.JavaScript.valueToCode(block, 'INDEX', Blockly.JavaScript.ORDER_ATOMIC); return `${variable_object}.addChildAt(${value_child}, ${value_index});\\n`; }; /** * Adds a child to the given object at the given index. * @method add_child_at_vi * @param object the object to add a child to * @param child the child to add to the object * @param index {Number} the index to add the child to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.addChildAt(child, index); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['add_child_at_vi'] = function (block) { const child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const index = Blockly.JavaScript.valueToCode(block, 'INDEX', Blockly.JavaScript.ORDER_ATOMIC) || '0'; return `${object}.addChildAt(${child}, ${index});\\n`; }; /** * Align an object inside of another object. * @method align_in * @param object object to align * @param container object to align to * @param position {Number} position to justify the alignment to * @param offset_x {Number} horizontal adjustment of the alignment * @param offset_y {Number} vertical adjustment of the alignment * @returns {} * &lt;pre&gt;&lt;code&gt; * object.alignIn(container, Phaser.position, offset_x, offset_y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['align_in'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const container = Blockly.JavaScript.valueToCode(block, 'CONTAINER', Blockly.JavaScript.ORDER_ATOMIC); const dropdown_position = block.getFieldValue('POSITION'); const offset_x = Blockly.JavaScript.valueToCode(block, 'OFFSETX', Blockly.JavaScript.ORDER_ATOMIC); const offset_y = Blockly.JavaScript.valueToCode(block, 'OFFSETY', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.alignIn(${container}, Phaser.${dropdown_position}, ${offset_x}, ${offset_y});\\n`; }; /** * Align an object to the side of another object. * @method align_to * @param object object to align * @param container object to align to * @param position {Number} position to justify the alignment to * @param offset_x {Number} horizontal adjustment of the alignment * @param offset_y {Number} vertical adjustment of the alignment * @returns {} * &lt;pre&gt;&lt;code&gt; * object.alignTo(container, Phaser.position, offset_x, offset_y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['align_to'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const container = Blockly.JavaScript.valueToCode(block, 'CONTAINER', Blockly.JavaScript.ORDER_ATOMIC); const dropdown_position = block.getFieldValue('POSITION'); const offset_x = Blockly.JavaScript.valueToCode(block, 'OFFSETX', Blockly.JavaScript.ORDER_ATOMIC); const offset_y = Blockly.JavaScript.valueToCode(block, 'OFFSETY', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.alignTo(${container}, Phaser.${dropdown_position}, ${offset_x}, ${offset_y});\\n`; }; /** * Render an object on top of all other objects. * @method bring_to_top * @param object object to render * @returns {} * &lt;pre&gt;&lt;code&gt; * object.bringToTop(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['bring_to_top'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.bringToTop();\\n`; }; /** * If true, the game checks every frame to see if an object is within the world bounds, and returns a boolean with the result. * @method check_world_bounds * @param object object to check * @param bool {Boolean} enables/disables checking world bounds * @returns {} * &lt;pre&gt;&lt;code&gt; * object.checkWorldBounds = bool; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['check_world_bounds'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_bool = Blockly.JavaScript.valueToCode(block, 'BOOL', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.checkWorldBounds = ${value_bool};\\n`; }; /** * @deprecated * Checks if an object contains the given child. * @method contains * @param object object to check * @param child child to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.contains(child); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['contains'] = function (block) { const value_child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return [`${variable_object}.contains(${value_child})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Checks if an object contains the given child. * @method contains_vi * @param object object to check * @param child child to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.contains(child); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['contains_vi'] = function (block) { const value_child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.contains(${value_child})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Crop the image of an object to the given rectangular bounds. * @method crop * @param object object whose image is getting cropped * @param rectangle {Phaser.Rectangle} the rectangle bounds and properites to use for the crop * @returns {} * &lt;pre&gt;&lt;code&gt; * object.crop(rectangle); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['crop'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_rectangle = Blockly.JavaScript.valueToCode(block, 'RECTANGLE', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.crop(${value_rectangle});\\n`; }; /** * Clear the cropping on an object's image. * @method clear_cropping * @param object object whose image is cropped * @returns {} * &lt;pre&gt;&lt;code&gt; * object.crop(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['clear_cropping'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.crop();\\n`; }; /** * Destroy the given sprite object. * @method destroy_sprite * @param object object to destroy * @param bool {Boolean} whether or not the sprite's children should also be destroyed * @returns {} * &lt;pre&gt;&lt;code&gt; * object.destroy(bool); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['destroy_sprite'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_bool = Blockly.JavaScript.valueToCode(block, 'BOOL', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.destroy(${value_bool});\\n`; }; /** * @deprecated * Get the child at the given index. * @method get_child_at * @param object object to retrieve the child from * @param index {Number} index the child is located at * @returns {} * &lt;pre&gt;&lt;code&gt; * object.getChildAt(index); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['get_child_at'] = function (block) { const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); const value_index = Blockly.JavaScript.valueToCode(block, 'INDEX', Blockly.JavaScript.ORDER_ATOMIC); return [`${variable_object}.getChildAt(${value_index})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Get the child at the given index. * @method get_child_at_vi * @param object object to get the child from * @param index {Number} index the child is located at * @returns {} * &lt;pre&gt;&lt;code&gt; * object.getChildAt(index); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['get_child_at_vi'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_index = Blockly.JavaScript.valueToCode(block, 'INDEX', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.getChildAt(${value_index})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * @deprecated * Get the index of the given child. * @method get_child_index * @param object object to get the child from * @param child child to get the index from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.getChildIndex(child); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['get_child_index'] = function (block) { const value_child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return [`${variable_object}.getChildIndex(${value_child})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Get the index of the given child. * @method get_child_index_vi * @param object object to get the child from * @param child child to get the index from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.getChildIndex(child); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['get_child_index_vi'] = function (block) { const child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.getChildIndex(${child})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Changes the image of a sprite object. * @method load_texture * @param object object whose image is getting changed * @param tag {String} the tag of the texture to change the image to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.loadTexture(tag); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['load_texture'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_texture = Blockly.JavaScript.valueToCode(block, 'TEXTURE', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.loadTexture(${value_texture});\\n`; }; /** * Moves the object down one layer in the display list. * @method move_down * @param object object to render * @returns {} * &lt;pre&gt;&lt;code&gt; * object.moveDown(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['move_down'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.moveDown();\\n`; }; /** * Moves the object up one layer in the display list. * @method move_up * @param object object to render * @returns {} * &lt;pre&gt;&lt;code&gt; * object.moveUp(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['move_up'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.moveUp();\\n`; }; /** * @deprecated * Checks to see if two objects overlap. * @method sprite_overlap * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['sprite_overlap'] = function (block) { const value_sprite_a = Blockly.JavaScript.valueToCode(block, 'SPRITEA', Blockly.JavaScript.ORDER_ATOMIC); const value_sprite_b = Blockly.JavaScript.valueToCode(block, 'SPRITEB', Blockly.JavaScript.ORDER_ATOMIC); return [`${value_sprite_a}.overlap(${value_sprite_b})`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @method out_of_bounds_kill * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['out_of_bounds_kill'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_bool = Blockly.JavaScript.valueToCode(block, 'BOOL', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.outOfBoundsKill = ${value_bool};\\n`; }; /** * If true, the object gets deleted if it leaves the world bounds. * @method out_of_bounds_faint * @param object object that gets deleted * @param boolean {Boolean} sets the action to true or false * @returns {} * &lt;pre&gt;&lt;code&gt; * object.outOfBoundsFaint = boolean; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['out_of_bounds_faint'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_bool = Blockly.JavaScript.valueToCode(block, 'BOOL', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.outOfBoundsFaint = ${value_bool};\\n`; }; /** * @deprecated * @param block * @return {String} * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['remove_child'] = function (block) { const value_child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return `${variable_object}.removeChild(${value_child});\\n`; }; /** * @deprecated * @param block * @return {String} * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['remove_child_at'] = function (block) { const value_index = Blockly.JavaScript.valueToCode(block, 'INDEX', Blockly.JavaScript.ORDER_ATOMIC); const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return `${variable_object}.removeChildAt(${value_index});\\n`; }; /** * @deprecated * @param block * @return {String} * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['remove_children'] = function (block) { const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return `${variable_object}.removeChildren();\\n`; }; /** * Removes the given child from the object. * @method remove_child_vi * @param object object to remove the child from * @param child child to remove from the object * @returns {} * &lt;pre&gt;&lt;code&gt; * object.removeChild(child); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['remove_child_vi'] = function (block) { const child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.removeChild(${child});\\n`; }; /** * Removes the child at the given index from the object. * @method remove_child_at_vi * @param object object to remove the child from * @param index index of the child to remove from the object * @returns {} * &lt;pre&gt;&lt;code&gt; * object.removeChildAt(index); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['remove_child_at_vi'] = function (block) { const value_index = Blockly.JavaScript.valueToCode(block, 'INDEX', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.removeChildAt(${value_index});\\n`; }; /** * Removes all children from the object. * @method remove_children_vi * @params object object to remove children from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.removeChildren(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['remove_children_vi'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.removeChildren();\\n`; }; /** * @deprecated * Resets the dimensions of the frame the Game Object uses for rendering. * @method reset_frame * @param object object to reset * @returns {} * &lt;pre&gt;&lt;code&gt; * object.resetFrame(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['reset_frame'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.resetFrame();\\n`; }; /** * @deprecated * @method resize_frame * @param * @returns {} * &lt;pre&gt;&lt;code&gt; * * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['resize_frame'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_parent = Blockly.JavaScript.valueToCode(block, 'PARENT', Blockly.JavaScript.ORDER_ATOMIC); const value_width = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_ATOMIC); const value_height = Blockly.JavaScript.valueToCode(block, 'HEIGHT', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.resetFrame(${value_parent}, ${value_width}, ${value_height});\\n`; }; /** * Render an object below all other objects. * @method send_to_back * @param object object to render * @returns {} * &lt;pre&gt;&lt;code&gt; * object.sendToBack(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['send_to_back'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.sendToBack();\\n`; }; /** * @deprecated * @param block * @return {String} * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['set_child_index'] = function (block) { const value_child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); const variable_parent = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('PARENT'), Blockly.Variables.NAME_TYPE); const value_index = Blockly.JavaScript.valueToCode(block, 'INDEX', Blockly.JavaScript.ORDER_ATOMIC); return `${variable_parent}.setChildIndex(${value_child}, ${value_index});\\n`; }; /** * Sets the position of the child in the object's list of children. * @method set_child_index_vi * @param object object that contains the child * @param child child to change the position of * @param index {Number} index to set the child's position to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.setChildIndex(child, index); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['set_child_index_vi'] = function (block) { const child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const index = Blockly.JavaScript.valueToCode(block, 'INDEX', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.setChildIndex(${child}, ${index});\\n`; }; /** * Sets the texture frame for the object to use for rendering. * @method set_sprite_frame * @param object object to set the frame for * @param frame frame to set the texture to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.setFrame(frame); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['set_sprite_frame'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_frame = Blockly.JavaScript.valueToCode(block, 'FRAME', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.setFrame(${value_frame});\\n`; }; /** * Sets the limits for how the object will scale based on it's parent. * @method set_scale_min_max * @param object object to set the scale constraints for * @param minX {Number} the minimum horizontal scale the Game Object can scale down to * @param minY {Number} the minimum vertical scale the Game Object can scale down to * @param maxX {Number} the maximum horizontal scale the Game Object can scale down to * @param maxY {Number} the maximum vertical scale the Game Object can scale down to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.setScaleMinMax(minX, minY, maxX, maxY); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['set_scale_min_max'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const minX = Blockly.JavaScript.valueToCode(block, 'MINX', Blockly.JavaScript.ORDER_ATOMIC); const minY = Blockly.JavaScript.valueToCode(block, 'MINY', Blockly.JavaScript.ORDER_ATOMIC); const maxX = Blockly.JavaScript.valueToCode(block, 'MAXX', Blockly.JavaScript.ORDER_ATOMIC); const maxY = Blockly.JavaScript.valueToCode(block, 'MAXY', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.setScaleMinMax(${minX}, ${minY}, ${maxX}, ${maxY});\\n`; }; /** * Clears all scale constraints set on the object. * @method clear_scale_min_max * @param object object to clear scale constraints from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.setScaleMinMax(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['clear_scale_min_max'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.setScaleMinMax();\\n`; }; /** * @deprecated * @method * @param * @param * @returns {} * &lt;pre&gt;&lt;code&gt; * * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['set_texture'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_texture = Blockly.JavaScript.valueToCode(block, 'TEXTURE', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.setTexture(${value_texture});\\n`; }; /** * Swaps the position of the two children in the object's list. * @method swap_children * @param parent parent of the children who are being swapped * @param child to be swapped with child2 * @param child2 to be swapped with cihld * @returns {} * &lt;pre&gt;&lt;code&gt; * parent.swapChildren(child, child2); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sprite/Image * @block */ Blockly.JavaScript['swap_children'] = function (block) { const value_parent = Blockly.JavaScript.valueToCode(block, 'PARENT', Blockly.JavaScript.ORDER_ATOMIC); const value_child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); const value_child2 = Blockly.JavaScript.valueToCode(block, 'CHILD2', Blockly.JavaScript.ORDER_ATOMIC); return `${value_parent}.swapChildren(${value_child}, ${value_child2});\\n`; }; //endregion /** * @namespace Groups */ //region GROUPS /** * @deprecated * @method * @param * @returns {} * &lt;pre&gt;&lt;code&gt; * * &lt;/code&gt;&lt;/pre&gt; * @block */ Blockly.JavaScript['create_object_in_group'] = function (block) { const xPos = Blockly.JavaScript.valueToCode(block, 'X_POS', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const yPos = Blockly.JavaScript.valueToCode(block, 'Y_POS', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const tag = block.getFieldValue('TAG'); const group = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('GROUP'), Blockly.Variables.NAME_TYPE); return [`${group}.create(${xPos}, ${yPos}, '${tag}')`, Blockly.JavaScript.ORDER_NONE]; }; /** * Creates an object at a position with the given tag, and adds it to the front of the group. * @method create_object_in_group_vi * @param x {Number} the x coordinate to display the new object at, relative to the position of the group * @param y {Number} the y coordinate to display the new object at, relative to the position of the group * @param tag {String} the tag of the image to assign to the object * @returns {} * &lt;pre&gt;&lt;code&gt; * group.create(x, y, tag); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['create_object_in_group_vi'] = function (block) { const x = Blockly.JavaScript.valueToCode(block, 'X_POS', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const y = Blockly.JavaScript.valueToCode(block, 'Y_POS', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const tag = Blockly.JavaScript.valueToCode(block, 'TAG', Blockly.JavaScript.ORDER_ATOMIC); const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); return [`${group}.create(${x}, ${y}, ${tag})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Creates a container to hold multiple sprites. Assign to a variable for future use. * @method create_group * @returns {} * &lt;pre&gt;&lt;code&gt; * game.add.group(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['create_group'] = function (block) { return [`game.add.group()`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['create_object_in_group_with_frame'] = function (block) { const xPos = Blockly.JavaScript.valueToCode(block, 'X_POS', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const yPos = Blockly.JavaScript.valueToCode(block, 'Y_POS', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const frame = Blockly.JavaScript.valueToCode(block, 'FRAME', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const tag = block.getFieldValue('TAG'); const group = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('GROUP'), Blockly.Variables.NAME_TYPE); return [`${group}.create(${xPos}, ${yPos}, '${tag}, ${frame}')`, Blockly.JavaScript.ORDER_NONE]; }; /** * Creates a new object from the tag and adds it to the front of the group. Assign to a variable for future use. * @method create_object_in_group_with_frame_vi * @param x {Number} the x position for the object to be displayed at * @param y {Number} the y position for the object to be displayed at * @param frame {Number} the frame of the sprite sheet to display at the start * @param tag {String} the sprite to display on the object * @param group the group to add the object to * @returns {} * &lt;pre&gt;&lt;code&gt; * group.create(x, y, tag, frame); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['create_object_in_group_with_frame_vi'] = function (block) { const xPos = Blockly.JavaScript.valueToCode(block, 'X_POS', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const yPos = Blockly.JavaScript.valueToCode(block, 'Y_POS', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const frame = Blockly.JavaScript.valueToCode(block, 'FRAME', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const tag = Blockly.JavaScript.valueToCode(block, 'TAG', Blockly.JavaScript.ORDER_ATOMIC); const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); return [`${group}.create(${xPos}, ${yPos}, ${tag}, ${frame})`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @returns {String} * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['call_function_on_group'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); const func_name = Blockly.JavaScript.valueToCode(block, 'FUNCTION', Blockly.JavaScript.ORDER_ATOMIC); return `${group}.forEachAlive(${func_name}, this);\\n`; }; /** * Adds the given object to the front of the group. * @method add_to_group * @param object object that gets added to the group * @param group group that the object is getting added to * @returns {} * &lt;pre&gt;&lt;code&gt; * group.add(object); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['add_to_group'] = function (block) { const newItem = Blockly.JavaScript.valueToCode(block, 'NEW_ITEM', Blockly.JavaScript.ORDER_ATOMIC); const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); return `${group}.add(${newItem});\\n`; }; /** * Removes the given object from the group, with the option to remove it from the game as well. * @method remove_from_group * @param object object that gets removed from the group * @param group group that the object is getting removed from * @param destroy {Boolean} option to remove the object from the game * @returns {} * &lt;pre&gt;&lt;code&gt; * group.remove(object, destroy); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['remove_from_group'] = function (block) { const child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); const destroy = block.getFieldValue('DESTROY') == 'TRUE'; return `${group}.remove(${child}, ${destroy});\\n`; }; /** * Figures out if the group contains the object, and returns true or false. * @method group_contains * @param group group to check * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * group.contains(child); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['group_contains'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); const child = Blockly.JavaScript.valueToCode(block, 'CHILD', Blockly.JavaScript.ORDER_ATOMIC); return [`${group}.contains(${child})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Figures out how many objects are alive or fainted in the group, and returns the number. * @method group_count_alive_dead * @param group group to check * @param state determines if you are checking alive or fainted. * @returns {} * &lt;pre&gt;&lt;code&gt; * group.count(state); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['group_count_alive_dead'] = function (block) { const state = block.getFieldValue('STATE'); const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); return [`${group}.count${state}()`, Blockly.JavaScript.ORDER_NONE]; }; /** * Removes all objects and deletes the group, with the option to delete the objects as well. * @method destroy_group * @param group group to destroy * @param handleChildren option to delete all containing objects * @returns {} * &lt;pre&gt;&lt;code&gt; * group.destroy(handleChildren); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['destroy_group'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); const handleChildren = block.getFieldValue('HANDLE_CHILDREN') == 'TRUE'; return `${group}.destroy(${handleChildren});\\n`; }; /** * Returns all objects in the group, to make changes or get information from them all at the same time. * @method group_get_all * @param group group to get all objects from * @returns {} * &lt;pre&gt;&lt;code&gt; * group.getAll(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['group_get_all'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); return [`${group}.getAll()`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns the object at the position of the given index in the group. * @method group_get_at * @param group group to get the object from * @param index {Number} position of the object in the group * @returns {} * &lt;pre&gt;&lt;code&gt; * group.getAt(index); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['group_get_at'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); const index = Blockly.JavaScript.valueToCode(block, 'INDEX', Blockly.JavaScript.ORDER_ATOMIC); return [`${group}.getAt(${index})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns the object in the group physically closest to the given object, based on their x/y coordinates. * @method group_get_closest_to * @param group group to get the object from * @param object object to base the position from * @returns {} * &lt;pre&gt;&lt;code&gt; * group.getClosestTo(object); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['group_get_closest_to'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${group}.getClosestTo(${object})`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['group_get_first_alive_dead'] = function (block) { const mode = block.getFieldValue('MODE'); const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); return [`${group}.getFirst${mode}()`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns the first object closest to the front of the group that is alive/fainted. * @method group_get_first_alive_fainted * @param group group to get the object from * @param mode determines if you are checking for an alive or fainted object * @returns {} * &lt;pre&gt;&lt;code&gt; * group.getFirstMode(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['group_get_first_alive_fainted'] = function (block) { const mode = block.getFieldValue('MODE'); const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); return [`${group}.getFirst${mode}()`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns a randomly chosen object from the group. * @method group_get_random * @param group group to get the object from * @returns {} * &lt;pre&gt;&lt;code&gt; * group.getRandom(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['group_get_random'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); return [`${group}.getRandom()`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns a randomly chosen object from the group that has exists set to true. * @method group_get_random_exists * @param group group to get the object from * @returns {} * &lt;pre&gt;&lt;code&gt; * group.getRandomExists(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['group_get_random_exists'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); return [`${group}.getRandomExists()`, Blockly.JavaScript.ORDER_NONE]; }; /** * Remove all members from the group, with the option to delete them as well. * @method group_remove_all * @param group group to remove the objects from * @param deleteObjects {Boolean} option to delete the objects after removing them from the group * @returns {} * &lt;pre&gt;&lt;code&gt; * group.removeAll(deleteObjects); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['group_remove_all'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); const deleteObjects = block.getFieldValue('DESTROY_CHILDREN') == 'TRUE'; return `${group}.removeAll(${deleteObjects});\\n`; }; /** * Adds the object to the top of the World group. * @method add_to_world * @param object object to add to the group * @returns {} * &lt;pre&gt;&lt;code&gt; * game.world.add(object); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Groups * @block */ Blockly.JavaScript['add_to_world'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `game.world.add(${object});\\n`; }; //endregion /** * @namespace Animation */ //region ANIMATION /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['play_animation'] = function (block) { const animation = Blockly.JavaScript.valueToCode(block, 'ANIMATION', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return `${object}.animations.play(${animation});\\n`; }; /** * Plays an existing animation based on the given tag. * @method play_animation_vi * @param animation {String} the name of the animation to play * @param object object to play the animation on * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.play(animation); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['play_animation_vi'] = function (block) { const animation = Blockly.JavaScript.valueToCode(block, 'ANIMATION', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || null; return `${object}.animations.play(${animation});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['stop_animation'] = function (block) { const object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return `${object}.animations.stop();\\n`; }; /** * Stops the current animation on the object. * @method stop_animation_vi * @param object object to stop the animations on * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.stop(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['stop_animation_vi'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.animations.stop();\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_frame'] = function (block) { const frameNumber = Blockly.JavaScript.valueToCode(block, 'FRAME_NUMBER', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return `${object}.frame = ${frameNumber};\\n`; }; /** * Sets the frame for the current animation on the object. * @method set_frame_vi * @param object object to set the animation frame for * @param frameNumber {Number} frame to set the animation to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.frame = frameNumber; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['set_frame_vi'] = function (block) { const frameNumber = Blockly.JavaScript.valueToCode(block, 'FRAME_NUMBER', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.frame = ${frameNumber};\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['animation_get_animation'] = function (block) { const value_sprite = Blockly.JavaScript.valueToCode(block, 'Sprite', Blockly.JavaScript.ORDER_ATOMIC); const text_name = block.getFieldValue('NAME'); return [`${value_sprite}.animations.getAnimation(&quot;${text_name}&quot;)`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * @deprecated * @param block * @return {} * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['animation_next'] = function (block) { const number_framecount = block.getFieldValue('FRAMECOUNT'); const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return `${variable_object}.animations.next(${number_framecount});\\n`; }; /** * @deprecated * @param block * @return {} * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['animation_previous'] = function (block) { const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); const number_framecount = block.getFieldValue('FRAMECOUNT'); return `${variable_object}.animations.previous(${number_framecount});\\n`; }; /** * Increases the animation by the given number of frames. * @method animation_next_vi * @param framecount {Number} number of frames to advance * @param objet object with the animation to change * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.next(framecount); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['animation_next_vi'] = function (block) { const framecount = Blockly.JavaScript.valueToCode(block, 'FRAMECOUNT', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.animations.next(${framecount});\\n`; }; /** * Moves the animation backwards by the given number of frames. * @method animation_next_vi * @param framecount {Number} number of frames to move back * @param objet object with the animation to change * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.previous(framecount); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['animation_previous_vi'] = function (block) { const framecount = Blockly.JavaScript.valueToCode(block, 'FRAMECOUNT', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.animations.previous(${framecount});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['refresh_frame'] = function (block) { const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return `${variable_object}.animations.refreshFrame();\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['animation_update'] = function (block) { const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return [`${variable_object}.animations.update()`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['validate_frames'] = function (block) { const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('Object'), Blockly.Variables.NAME_TYPE); const value_frames = Blockly.JavaScript.valueToCode(block, 'FRAMES', Blockly.JavaScript.ORDER_ATOMIC); return [`${variable_object}.animations.validateFrames(${value_frames}, true)`, Blockly.JavaScript.ORDER_NONE]; }; /** * Checks if the given frames are valid and exist in the object's animation. * @method validate_frames_vi * @param object object to check the animation of * @param frames {Array} frames to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.validateFrames(frames, true) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['validate_frames_vi'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const frames = Blockly.JavaScript.valueToCode(block, 'FRAMES', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.animations.validateFrames(${frames}, true)`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @return {String} * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['animation_destroy'] = function (block) { const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return `${variable_object}.animations.destroy();\\n`; }; /** * Destroy all animations on an object. * @method animation_destroy_vi * @param object object to destroy the animations of * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.destroy(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['animation_destroy_vi'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.animations.destroy();\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['get_animation_property'] = function (block) { const value_sprite = Blockly.JavaScript.valueToCode(block, 'SPRITE', Blockly.JavaScript.ORDER_ATOMIC); const dropdown_field = block.getFieldValue('FIELD'); return [`${value_sprite}.animations.${dropdown_field}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_animation_property'] = function (block) { const dropdown_field = block.getFieldValue('FIELD'); const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); const value_newproperty = Blockly.JavaScript.valueToCode(block, 'NEWPROPERTY', Blockly.JavaScript.ORDER_ATOMIC); return `${variable_object}.animations.${dropdown_field} = ${value_newproperty};\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_animation_property_vi'] = function (block) { const field = block.getFieldValue('FIELD'); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const newProperty = block.getFieldValue('VALUE') == 'TRUE'; return `${object}.animations.${field} = ${newProperty};\\n`; }; // Animation SET blocks /** * Assigns the chosen boolean field for the object. * @method set_animation_boolean_field_vi * @param field the value to set * @param object object to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.currentAnim.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ /** * Assigns the chosen numeric field for the object. * @method set_animation_numeric_field * @param field the value to set * @param object object to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.currentAnim.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ /** * Assigns the chosen string field for the object. * @method set_animation_string_field * @param field the value to set * @param object object to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.currentAnim.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['set_animation_boolean_field_vi'] = Blockly.JavaScript['set_animation_numeric_field'] = Blockly.JavaScript['set_animation_string_field'] = function (block) { const field = block.getFieldValue('FIELD'); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.animations.currentAnim.${field} = ${value};\\n`; }; // Animation GET blocks /** * Returns the chosen boolean field value of the object. * @method get_animation_boolean_field_vi * @param field the value to get * @param object object to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.currentAnim.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ /** * Returns the chosen numeric field value of the object. * @method get_animation_numeric_field * @param field the value to get * @param object object to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.currentAnim.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ /** * Returns the chosen string field value of the object. * @method get_animation_string_field * @param field the value to get * @param object object to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.animations.currentAnim.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Animation * @block */ Blockly.JavaScript['get_animation_boolean_field_vi'] = Blockly.JavaScript['get_animation_numeric_field'] = Blockly.JavaScript['get_animation_string_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('FIELD'); return [`${object}.animations.currentAnim.${field}`, Blockly.JavaScript.ORDER_ATOMIC]; }; //endregion /** * @namespace PhaserText */ //region PHASERTEXT /** * Creates a new text object and adds it to the game. * @method add_text_input * @param x {Number} the x coordinate to display the text at * @param y {Number} the y coordinate to display the text at * @param initial_text {String} the text to display * @param size {Number} the font size to display the text with * @param colour the colour to display the text with * @returns {} * &lt;pre&gt;&lt;code&gt; * game.add.text(x, y, initial_text, {fontSize: `${size}px`, fill: 'colour'}) * &lt;/code&gt;&lt;/pre&gt; * @memberOf PhaserText * @block */ Blockly.JavaScript['add_text_input'] = function (block) { const x = Blockly.JavaScript.valueToCode(block, 'X_POS', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y_POS', Blockly.JavaScript.ORDER_ATOMIC); const initial_text = Blockly.JavaScript.valueToCode(block, 'INITIAL_TEXT', Blockly.JavaScript.ORDER_ATOMIC); const size = Blockly.JavaScript.valueToCode(block, 'FONT_SIZE', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return [`game.add.text(${x}, ${y}, ${initial_text}, { fontSize: \\`\\${${size}}px\\`, fill: ${colour}})`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['add_text'] = function (block) { const value_x_pos = Blockly.JavaScript.valueToCode(block, 'X_POS', Blockly.JavaScript.ORDER_ATOMIC); const value_y_pos = Blockly.JavaScript.valueToCode(block, 'Y_POS', Blockly.JavaScript.ORDER_ATOMIC); const value_initial_text = Blockly.JavaScript.valueToCode(block, 'INITIAL_TEXT', Blockly.JavaScript.ORDER_ATOMIC); const size = Blockly.JavaScript.valueToCode(block, 'FONT_SIZE', Blockly.JavaScript.ORDER_ATOMIC); const colour_fill = block.getFieldValue('FILL'); return [`game.add.text(${value_x_pos}, ${value_y_pos}, ${value_initial_text}, { fontSize: \\`\\${${size}}px\\`, fill: '${colour_fill}'})`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_text'] = function (block) { const object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); const text_string = Blockly.JavaScript.valueToCode(block, 'TEXT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.text = ${text_string};\\n`; }; /** * Sets the text to display on the text object. * @method set_text_vi * @param object text object to set the text for * @param text_string {String} text to display on the object * @returns {} * &lt;pre&gt;&lt;code&gt; * object.text = text_string; * &lt;/code&gt;&lt;/pre&gt; * @memberOf PhaserText * @block */ Blockly.JavaScript['set_text_vi'] = function (block) { const variable_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_text = Blockly.JavaScript.valueToCode(block, 'TEXT', Blockly.JavaScript.ORDER_ATOMIC); return `${variable_object}.text = ${value_text};\\n`; }; //endregion /** * @namespace Particles */ //region PARTICLES /** * Creates a particle emitter at the given location, with a total number of max particles. * @method addemitter * @param x {Number} the x location of the emitter * @param y {Number} the y location of the emitter * @param maxparticles {Number} the total number of particles in the emitter * @returns {} * &lt;pre&gt;&lt;code&gt; * game.add.emitter(x, y, maxparticles) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Particles * @block */ Blockly.JavaScript['addemitter'] = function (block) { const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const maxparticles = Blockly.JavaScript.valueToCode(block, 'maxParticles', Blockly.JavaScript.ORDER_ATOMIC) || '1'; return [`game.add.emitter(${x}, ${y}, ${maxparticles})`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['emitters_make_particles'] = function (block) { const emitter = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('EMITTER'), Blockly.Variables.NAME_TYPE); const tag = block.getFieldValue('TAG'); return `${emitter}.makeParticles('${tag}');\\n`; }; /** * Generates new particles to be used by the emitter. * @method emitters_make_particles * @param emitter emitter to make new particles for * @param keys {String} the sprite/texture to use for the particles * @param frames {Number} the frames the sprites will use * @param quantity {Number} the number of particles to generate * @param collide {Boolean} whether or not the particles should collide with physics bodies * @param collideWorldBounds {Boolean} whether or not the particles should collide with the world bounds * @returns {} * &lt;pre&gt;&lt;code&gt; * emitter.makeParticles(keys, frames, quantity, collide, collideWorldBounds); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Particles * @block */ Blockly.JavaScript['emitter_make_particles'] = function (block) { const emitter = Blockly.JavaScript.valueToCode(block, 'EMITTER', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const keys = Blockly.JavaScript.valueToCode(block, 'KEYS', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const frames = Blockly.JavaScript.valueToCode(block, 'FRAMES', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const quantity = Blockly.JavaScript.valueToCode(block, 'QUANTITY', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const collide = block.getFieldValue('COLLIDE') == 'TRUE'; const collideWorldBounds = block.getFieldValue('COLLIDEWORLDBOUNDS') == 'TRUE'; return `${emitter}.makeParticles(${keys}, ${frames}, ${quantity}, ${collide}, ${collideWorldBounds});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['emitters_set_rotation'] = function (block) { const variable_emitter = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('EMITTER'), Blockly.Variables.NAME_TYPE); const x_rotation = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || 0; const y_rotation = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || 0; return `${variable_emitter}.setRotation(${x_rotation}, ${y_rotation});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['emitters_set_rotation_vi'] = function (block) { const emitter = Blockly.JavaScript.valueToCode(block, 'EMITTER', Blockly.JavaScript.ORDER_ATOMIC); const min = Blockly.JavaScript.valueToCode(block, 'MIN', Blockly.JavaScript.ORDER_ATOMIC); const max = Blockly.JavaScript.valueToCode(block, 'MAX', Blockly.JavaScript.ORDER_ATOMIC); return `${emitter}.setRotation(${min}, ${max});\\n`; }; /** * @deprecated * @param block * @return {} * &lt;/code&gt;&lt;/pre&gt; * @memberOf Particles * @block */ Blockly.JavaScript['emitters_set_alpha'] = function (block) { const variable_emitter = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('EMITTER'), Blockly.Variables.NAME_TYPE); const value_min = Blockly.JavaScript.valueToCode(block, 'MIN', Blockly.JavaScript.ORDER_ATOMIC); const value_max = Blockly.JavaScript.valueToCode(block, 'MAX', Blockly.JavaScript.ORDER_ATOMIC); const value_rate = Blockly.JavaScript.valueToCode(block, 'RATE', Blockly.JavaScript.ORDER_ATOMIC) || null; return `${variable_emitter}.setAlpha(${value_min}, ${value_max}, ${value_rate});\\n`; }; /** * Sets the alpha constraints and variations for the particles on the emitter. * @method emitters_set_alpha_vi * @param emitter emitter to change the particles of * @param min {Number} the minimum value the alpha of the particles can reach * @param max {Number} the maximum value the alpha of the particles can reach * @param rate {Number} the rate the particles will change between min and max * @returns {} * &lt;pre&gt;&lt;code&gt; * emitter.setAlpha(min, max, rate); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Particles * @block */ Blockly.JavaScript['emitters_set_alpha_vi'] = function (block) { const emitter = Blockly.JavaScript.valueToCode(block, 'EMITTER', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const min = Blockly.JavaScript.valueToCode(block, 'MIN', Blockly.JavaScript.ORDER_ATOMIC) || '1'; const max = Blockly.JavaScript.valueToCode(block, 'MAX', Blockly.JavaScript.ORDER_ATOMIC) || '1'; const rate = Blockly.JavaScript.valueToCode(block, 'RATE', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; return `${emitter}.setAlpha(${min}, ${max}, ${rate});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['emitters_set_scale'] = function (block) { const variable_emitter = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('EMITTER'), Blockly.Variables.NAME_TYPE); const value_minx = Blockly.JavaScript.valueToCode(block, 'MINX', Blockly.JavaScript.ORDER_ATOMIC) || null; const value_maxx = Blockly.JavaScript.valueToCode(block, 'MAXX', Blockly.JavaScript.ORDER_ATOMIC) || null; const value_miny = Blockly.JavaScript.valueToCode(block, 'MINY', Blockly.JavaScript.ORDER_ATOMIC) || null; const value_maxy = Blockly.JavaScript.valueToCode(block, 'MAXY', Blockly.JavaScript.ORDER_ATOMIC) || null; const value_rate = Blockly.JavaScript.valueToCode(block, 'RATE', Blockly.JavaScript.ORDER_ATOMIC) || null; return `${variable_emitter}.setScale(${value_minx}, ${value_maxx}, ${value_miny}, ${value_maxy}, ${value_rate});\\n`; }; /** * Sets the scale constraints and variations for the particles on the emitter. * @method emitters_set_scale_vi * @param emitter emitter to change the particles of * @param minx {Number} the minimum x value the scale the particles can reach * @param maxx {Number} the maximum x value the scale the particles can reach * @param miny {Number} the minimum y value the scale the particles can reach * @param maxy {Number} the maximum y value the scale the particles can reach * @param rate {Number} the rate the particles will change between min and max * @returns {} * &lt;pre&gt;&lt;code&gt; * emitter.setScale(minx, maxx, miny, maxy, rate); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Particles * @block */ Blockly.JavaScript['emitters_set_scale_vi'] = function (block) { const emitter = Blockly.JavaScript.valueToCode(block, 'EMITTER', Blockly.JavaScript.ORDER_ATOMIC); const minx = Blockly.JavaScript.valueToCode(block, 'MINX', Blockly.JavaScript.ORDER_ATOMIC) || null; const maxx = Blockly.JavaScript.valueToCode(block, 'MAXX', Blockly.JavaScript.ORDER_ATOMIC) || null; const miny = Blockly.JavaScript.valueToCode(block, 'MINY', Blockly.JavaScript.ORDER_ATOMIC) || null; const maxy = Blockly.JavaScript.valueToCode(block, 'MAXY', Blockly.JavaScript.ORDER_ATOMIC) || null; const rate = Blockly.JavaScript.valueToCode(block, 'RATE', Blockly.JavaScript.ORDER_ATOMIC) || null; return `${emitter}.setScale(${minx}, ${maxx}, ${miny}, ${maxy}, ${rate});\\n`; }; /** * @deprecated * @param block * @return {} * &lt;/code&gt;&lt;/pre&gt; * @memberOf Particles * @block */ Blockly.JavaScript['emitters_set_speed'] = function (block) { const variable_emitter = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('EMITTER'), Blockly.Variables.NAME_TYPE); const value_minx = Blockly.JavaScript.valueToCode(block, 'MINX', Blockly.JavaScript.ORDER_ATOMIC) || null; const value_maxx = Blockly.JavaScript.valueToCode(block, 'MAXX', Blockly.JavaScript.ORDER_ATOMIC) || null; const value_miny = Blockly.JavaScript.valueToCode(block, 'MINY', Blockly.JavaScript.ORDER_ATOMIC) || null; const value_maxy = Blockly.JavaScript.valueToCode(block, 'MAXY', Blockly.JavaScript.ORDER_ATOMIC) || null; const setMin = `${variable_emitter}.minParticleSpeed.set(${value_minx}, ${value_miny});\\n`; const setMax = `${variable_emitter}.maxParticleSpeed.set(${value_maxx}, ${value_maxy});\\n`; return setMin + setMax; }; /** * Sets the maximum and minimum speeds of the particles released from the emitter. * @method emitters_set_speed_vi * @param emitter emitter to set the speed of the particles for * @param minx {Number} the minimum speed for the particles to move in the x direction * @param maxx {Number} the maximum speed for the particles to move in the x direction * @param miny {Number} the minimum speed for the particles to move in the y direction * @param maxy {Number} the maximum speed for the particles to move in the y direction * @returns {} * &lt;pre&gt;&lt;code&gt; * emitter.minParticleSpeed.set(minx, miny); emitter.maxParticleSpeed.set(maxx, maxy); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Particles * @block */ Blockly.JavaScript['emitters_set_speed_vi'] = function (block) { const emitter = Blockly.JavaScript.valueToCode(block, 'EMITTER', Blockly.JavaScript.ORDER_ATOMIC); const minx = Blockly.JavaScript.valueToCode(block, 'MINX', Blockly.JavaScript.ORDER_ATOMIC) || null; const maxx = Blockly.JavaScript.valueToCode(block, 'MAXX', Blockly.JavaScript.ORDER_ATOMIC) || null; const miny = Blockly.JavaScript.valueToCode(block, 'MINY', Blockly.JavaScript.ORDER_ATOMIC) || null; const maxy = Blockly.JavaScript.valueToCode(block, 'MAXY', Blockly.JavaScript.ORDER_ATOMIC) || null; const setMin = `${emitter}.minParticleSpeed.set(${minx}, ${miny});\\n`; const setMax = `${emitter}.maxParticleSpeed.set(${maxx}, ${maxy});\\n`; return setMin + setMax; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['emitters_set_gravity'] = function (block) { const emitter = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('EMITTER'), Blockly.Variables.NAME_TYPE); const gravity = Blockly.JavaScript.valueToCode(block, 'GRAVITY', Blockly.JavaScript.ORDER_ATOMIC) || 0; return `${emitter}.gravity = ${gravity};\\n`; }; /** * Sets the gravity each particle has when launched from the emitter. * @method emitters_set_gravity * @param emitter emitter to set the gravity of the particles for * @param particle_gravity {Number} the gravity each particle will have * @returns {} * &lt;pre&gt;&lt;code&gt; * emitter.gravity = particle_gravity; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Particles * @block */ Blockly.JavaScript['emitters_set_gravity_vi'] = function (block) { const emitter = Blockly.JavaScript.valueToCode(block, 'EMITTER', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const gravity = Blockly.JavaScript.valueToCode(block, 'GRAVITY', Blockly.JavaScript.ORDER_ATOMIC) || 0; return `${emitter}.gravity = ${gravity};\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['emitters_set_width'] = function (block) { const variable_emitter = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('EMITTER'), Blockly.Variables.NAME_TYPE); const value_width = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_ATOMIC) || 0; return `${variable_emitter}.width = ${value_width};\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['emitters_start'] = function (block) { const variable_emitter = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('EMITTER'), Blockly.Variables.NAME_TYPE); const bool_explode = Blockly.JavaScript.valueToCode(block, 'EXPLODE', Blockly.JavaScript.ORDER_ATOMIC) || null; const value_lifespan = Blockly.JavaScript.valueToCode(block, 'LIFESPAN', Blockly.JavaScript.ORDER_ATOMIC) || null; const value_frequency = Blockly.JavaScript.valueToCode(block, 'FREQUENCY', Blockly.JavaScript.ORDER_ATOMIC) || null; const value_quantity = Blockly.JavaScript.valueToCode(block, 'QUANTITY', Blockly.JavaScript.ORDER_ATOMIC) || null; return `${variable_emitter}.start(${bool_explode}, ${value_lifespan}, ${value_frequency}, ${value_quantity});\\n`; }; /** * Tell the emitter to start emitting particles. * @method emitters_start_vi * @param emitter emitter to start emitting particles from * @param explode {Boolean} whether the particles should burst out at once (true), or at the frequency given (false) * @param lifespan {Number} how long each particle lives once emitted * @param frequency {Number} the interval between the release of each particle * @param quantity {Number} how many particles to emit before turning off * @returns {} * &lt;pre&gt;&lt;code&gt; * emitter.start(explode, lifespan, frequncy, quantity); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Particles * @block */ Blockly.JavaScript['emitters_start_vi'] = function (block) { const emitter = Blockly.JavaScript.valueToCode(block, 'EMITTER', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const explode = block.getFieldValue('EXPLODE') == 'TRUE'; const lifespan = Blockly.JavaScript.valueToCode(block, 'LIFESPAN', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const frequency = Blockly.JavaScript.valueToCode(block, 'FREQUENCY', Blockly.JavaScript.ORDER_ATOMIC) || '250'; const quantity = Blockly.JavaScript.valueToCode(block, 'QUANTITY', Blockly.JavaScript.ORDER_ATOMIC) || '0'; return `${emitter}.start(${explode}, ${lifespan}, ${frequency}, ${quantity});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_emit_from'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'Object', Blockly.JavaScript.ORDER_ATOMIC); const dropdown_cord = block.getFieldValue('cord'); const value_emit_loc = Blockly.JavaScript.valueToCode(block, 'emit_loc', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.emit${dropdown_cord} = ${value_emit_loc};\\n`; }; //endregion EMITTERS /** * @namespace GameObject */ //region GAMEOBJECT //region GAMEOBJECT.PROPERTIES /*Blockly.JavaScript['set_game_object_point_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('PROPERTY'); const point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.${field}.copyFrom(${point});\\n`; };* &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ /** * Assigns the chosen point field for the game object. * @method set_game_object_point_field * @param field the field to set * @param point point to set the field to * @param object object to set the field for * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field.copyFrom(point); * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['set_game_object_point_field'] = setPointField; /** * Returns the chosen point field value of the game object. * @method get_physics_point_field * @param object object to get values from * @param field the field to get the value of * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['get_game_object_point_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('PROPERTY'); return [`${object}.${field}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_game_object_boolean_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('PROPERTY'); const value = block.getFieldValue('BOOLEAN') == 'TRUE'; return `${object}.${field} = ${value};\\n`; }; /** * Assigns the chosen boolean field for the game object. * @method set_game_object_boolean_field_vi * @param object object to set the field for * @param field the field to set * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['set_game_object_boolean_field_vi'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('PROPERTY'); const boolean = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.${field} = ${boolean};\\n`; }; /** * Returns the chosen boolean field value for the game object. * @method get_game_object_boolean_field * @param object object to get values from * @param field the field to get the value of * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['get_game_object_boolean_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('PROPERTY'); return [`${object}.${field}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Assigns the chosen numeric value for the game object. * @method set_game_object_numeric_field * @param object object to set the field for * @param field the field to set * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['set_game_object_numeric_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('PROPERTY'); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.${field} = ${value};\\n`; }; /** * Returns the chosen point numeric value for the game object. * @method get_game_object_numeric_field * @param object object to get the values from * @param field the field to get the value of * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['get_game_object_numeric_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('PROPERTY'); return [`${object}.${field}`, Blockly.JavaScript.ORDER_ATOMIC]; }; //endregion /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_object_anchor'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_NONE); const value_x_pos = Blockly.JavaScript.valueToCode(block, 'X_POS', Blockly.JavaScript.ORDER_ATOMIC); const value_y_pos = Blockly.JavaScript.valueToCode(block, 'Y_POS', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.anchor.setTo(${value_x_pos}, ${value_y_pos});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['kill_object'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.kill();\\n`; }; /** * Sets the values of game object alive, exists, and visible to false. Does not actually destroy the object or free it from memory. * @method faint_object * @param object object to faint * @returns {} * &lt;pre&gt;&lt;code&gt; * object.faint(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['faint_object'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.faint();\\n`; }; /** * Deletes everything about the game object. * @method destroy_object * @param object object to destroy * @returns {} * &lt;pre&gt;&lt;code&gt; * object.destroy(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['destroy_object'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.destroy();\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['object_inCamera'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.inCamera`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['camera_follow'] = function (block) { const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); // TODO: Assemble JavaScript into code variable. return `game.camera.follow(${variable_object}, undefined, 0.5, 0.5);\\n`; }; /** * Makes the game camera follow the object. * @method camera_follow_vi * @param object object for the camera to follow * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera.follow(object); * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['camera_follow_vi'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `game.camera.follow(${object});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['camera_follow_vi_complex'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `game.camera.follow(${object});\\n`; }; /** * Makes the game camera follow the object, with a specific style of following. * @method camera_follow_vi_styled * @param object object for the camera to follow * @param style the style of the camera following * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera.follow(object, Phaser.Camera.style); * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['camera_follow_vi_styled'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const style = block.getFieldValue('STYLE'); return `game.camera.follow(${object}, Phaser.Camera.${style});\\n`; }; /** * Makes the game camera follow the object, with a specific style of following. Lerp designates how much linear interpolation to use when horizontally tracking the object. The closer the values is to 1, the faster the camera will track. * @method camera_follow_vi_complex * @param object object for the camera to follow * @param lerpX {Number} linear interpolation in the x direction * @param lerpY {Number} linear interpolation in the y direction * @param style the style of the camera following * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera.follow(object, style, lerpX, lerpY); * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['camera_follow_vi_complex'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const lerpX = Blockly.JavaScript.valueToCode(block, 'LERP_X', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const lerpY = Blockly.JavaScript.valueToCode(block, 'LERP_Y', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const style = block.getFieldValue('STYLE'); return `game.camera.follow(${object}, ${style}, ${lerpX}, ${lerpY});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['get_camera'] = function (block) { return [`game.camera`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['object_set_to'] = function (block) { const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); const value_setx = Blockly.JavaScript.valueToCode(block, 'setx', Blockly.JavaScript.ORDER_ATOMIC); const value_sety = Blockly.JavaScript.valueToCode(block, 'sety', Blockly.JavaScript.ORDER_ATOMIC); return `${variable_object}.setTo(${value_setx}, ${value_sety});\\n`; }; // Blockly.JavaScript['send_to_back'] = function (block) { // const variable_object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); // return `game.world.sendToBack(${variable_object});\\n`; // }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['get_bounds'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${value_object}.getBounds()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['get_rotation'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${value_object}.angle`, Blockly.JavaScript.ORDER_NONE]; }; /** * Rotates the object by the number of degrees. 0 to 180 rotates clockwise, 0 to -180 rotates counterclockwise. * @method rotate * @param object object to rotate * @param value_angle {Number} number of degrees to rotate by * @returns {} * &lt;pre&gt;&lt;code&gt; * object.angle += value_angle; * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['rotate'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_angle = Blockly.JavaScript.valueToCode(block, 'ANGLE', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.angle += ${value_angle};\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_rotation'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_rotation = Blockly.JavaScript.valueToCode(block, 'ROTATION', Blockly.JavaScript.ORDER_ATOMIC); return `${value_object}.angle = ${value_angle};\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['get_local_bounds'] = function (block) { const value_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${value_object}.getLocalBounds()`, Blockly.JavaScript.ORDER_NONE]; }; /** * Moves the game object to the given coordinates, and sets properties fresh, exists, visible, and renderable to true. * @method reset * @param object object to reset * @param x {Number} x position to move the object to * @param y {Number} y position to move the object to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.reset(x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['reset'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X_POS', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y_POS', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.reset(${x}, ${y});\\n`; }; /** * Brings a fainted object back to &quot;life&quot;. Sets alive, exists, and visible to true. * @method revive * @param object object to revive * @returns {} * &lt;pre&gt;&lt;code&gt; * object.revive(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['revive'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.revive();\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['create_bitmapFont'] = function (block) { const tag = Blockly.JavaScript.valueToCode(block, 'TAG', Blockly.JavaScript.ORDER_NONE); const source = Blockly.JavaScript.valueToCode(block, 'SRC', Blockly.JavaScript.ORDER_NONE); const xml = Blockly.JavaScript.valueToCode(block, 'XML', Blockly.JavaScript.ORDER_NONE); return `game.load.bitmapFont(${tag}, ${source}, ${xml});\\n`; }; /** * Move the position of the object by the given amount, relative to the object's current position. * @method move_by * @param object object to move * @param x {Number} number of pixels in the x direction to move * @param y {Number} number of pixels in the y direction to move * @returns {} * &lt;pre&gt;&lt;code&gt; * object.position.add(x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf GameObject * @block */ Blockly.JavaScript['move_by'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.position.add(${x}, ${y});\\n`; }; //endregion × Search results Close "},"phaser_physics.js.html":{"id":"phaser_physics.js.html","title":"Source: phaser_physics.js","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Source: phaser_physics.js //region PHYSICS /** * @namespace Setup */ //region SETUP /** * @deprecated * @method * @returns {} * &lt;pre&gt;&lt;code&gt; * * &lt;/code&gt;&lt;/pre&gt; * @memberOf Setup * @block */ Blockly.JavaScript['start_physics'] = function (block) { const dropdown_system = block.getFieldValue('SYSTEM'); return `game.physics.startSystem(Phaser.Physics.${dropdown_system});\\n`; }; /** * Enables the Phaser Arcade phyiscs to be used in the game. * @method start_arcade_physics * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.startSystem(Phaser.Physics.ARCADE); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Setup * @block */ Blockly.JavaScript['start_arcade_physics'] = function () { return 'game.physics.startSystem(Phaser.Physics.ARCADE);\\n'; }; /** * @deprecated * Enables a physics body for all objects in the group. This allows the objects to collide with things and use other physics functionality. * @method enable_body_group * @param * @returns {} * &lt;pre&gt;&lt;code&gt; * * &lt;/code&gt;&lt;/pre&gt; * @memberOf Setup * @block */ Blockly.JavaScript['enable_body_group'] = function (block) { const group = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('object'), Blockly.Variables.NAME_TYPE); return `${group}.enableBody = true;\\n`; }; /** * Enables physics body for all objects in the group. This allows the objects to collide with other physics bodies and use other physics functionality. * @method enable_body_group_vi * @param group group to enable physics on * @returns {} * &lt;pre&gt;&lt;code&gt; * group.enableBody = true; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Setup * @block */ Blockly.JavaScript['enable_body_group_vi'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${group}.enableBody = true;\\n`; }; /** * @deprecated * Adds a physics body to the object. This allows the object to collide with other physics bodies and use other physics functionality. * @method enable_arcade_phy * @param * @returns {} * &lt;pre&gt;&lt;code&gt; * * &lt;/code&gt;&lt;/pre&gt; * @memberOf Setup * @block */ Blockly.JavaScript['enable_arcade_physics_for_object'] = function (block) { const object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('object'), Blockly.Variables.NAME_TYPE); return `game.physics.arcade.enable(${object});\\n`; }; /** * Adds a physics body to the object. This allows the object to collide with other physics bodies and use other physics functionality. * @method enable_arcade_physics_for_object_vi * @param object object to enable physics on * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.enable(object); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Setup * @block */ Blockly.JavaScript['enable_arcade_physics_for_object_vi'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.enable(${object});\\n`; }; //endregion /** * @namespace Body */ //region BODY /** * Renders a visual for the physics body of the object. Will appear as a semi transparent filled green rectangle. * @method debug_body * @param object object to render the body for * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.body(object); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['debug_body'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'BODY', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.body(${object});\\n`; }; /** * Sets the object's acceleration, velocity, and speed to 0. * @method stop_body * @param object object to set values for * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.stop(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['stop_body'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'BODY', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.body.stop();\\n`; }; /** * @deprecated * Assigns the chosen point field for the object. * @method set_body_field_point * @param field the field to set * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.field.copyFrom(value); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['set_body_field_point'] = function (block) { const field = block.getFieldValue('FIELD'); const element = block.getFieldValue('ELEMENT'); const object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC) || '0'; return `${object}.body.${field}.${element} = ${value};\\n`; }; /** * Assigns the chosen point field element for the object. * @method set_body_field_point_vi * @param field the field to set * @param element choose to assign the x or y element of the point * @object object to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.field.element = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['set_body_field_point_vi'] = function (block) { const field = block.getFieldValue('FIELD'); const element = block.getFieldValue('ELEMENT'); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC) || '0'; return `${object}.body.${field}.${element} = ${value};\\n`; }; /** * Assigns the chosen point field for the object. * @method set_body_field_point_class_vi * @param field the field to set * @param object object to assign values for * @param point point to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.field = point; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['set_body_field_point_class_vi'] = function (block) { const field = block.getFieldValue('FIELD'); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC) || 'new Point()'; return `${object}.body.${field} = ${point};\\n`; }; /** * Returns the chosen point field value of the object. * @method get_body_field_point_class * @param field the field to get the value of * @param object object to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['get_body_field_point_class'] = function (block) { const field = block.getFieldValue('FIELD'); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; return [`${object}.body.${field}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_body_boolean_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const field = block.getFieldValue('ELEMENT'); const boolean = block.getFieldValue('VALUE') == 'TRUE'; return `${object}.body.${field} = ${boolean};\\n`; }; /** * Assigns the chosen boolean field for the object. * @method set_body_boolean_field_vi * @param field the field to set * @param object object to assign values for * @param boolean value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.field = point; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['set_body_boolean_field_vi'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const element = block.getFieldValue('ELEMENT'); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.body.${element} = ${value};\\n`; }; /** * Returns the chosen boolean field value of the object. * @method get_body_boolean_field * @param element the value to get * @param object object to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.element * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['get_body_boolean_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const element = block.getFieldValue('ELEMENT'); return [`${object}.body.${element}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Assigns the chosen numeric field for the object. * @method set_body_numeric_field * @param element the value to set * @param object object to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.element = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['set_body_numeric_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const element = block.getFieldValue('ELEMENT'); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC) || '0'; return `${object}.body.${element} = ${value};\\n`; }; /** * Returns the chosen numeric field value of the object. * @method get_body_numeric_field * @param element the value to get * @param object object to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.element * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['get_body_numeric_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const element = block.getFieldValue('ELEMENT'); return [`${object}.body.${element}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Sets the width and height of the physics body for an object. * @method body_set_size * @param object object to set the body of * @param width {Number} width to set the body to * @param height {Number} height to set the body to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.setSize(width, height); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['body_set_size'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'BODY', Blockly.JavaScript.ORDER_ATOMIC); const width = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_ATOMIC); const height = Blockly.JavaScript.valueToCode(block, 'HEIGHT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.body.setSize(${width}, ${height});\\n`; }; /** * Sets the width and height of the physics body for an object, with an offset position. Offset is based on the anchor of the object. * @method body_set_size * @param object object to set the body of * @param width {Number} width to set the body to * @param height {Number} height to set the body to * @param offset_x {Number} the amount to move the physics body by in the x direction, based on the object's position and anchor * @param offset_y {Number} the amount to move the physics body by in the y direction, based on the object's position and anchor * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.setSize(width, height, offset_x, offset_y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Body * @block */ Blockly.JavaScript['body_set_size_complex'] = function (block) { const body = Blockly.JavaScript.valueToCode(block, 'BODY', Blockly.JavaScript.ORDER_ATOMIC); const width = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_ATOMIC); const height = Blockly.JavaScript.valueToCode(block, 'HEIGHT', Blockly.JavaScript.ORDER_ATOMIC); const offset_x = Blockly.JavaScript.valueToCode(block, 'OFFSET_X', Blockly.JavaScript.ORDER_ATOMIC); const offset_y = Blockly.JavaScript.valueToCode(block, 'OFFSET_Y', Blockly.JavaScript.ORDER_ATOMIC); return `${body}.body.setSize(${width}, ${height}, ${offset_x}, ${offset_y});\\n`; }; //endregion /** * @namespace Util */ //region UTIL /** * @deprecated * @method * @param * @returns {} * &lt;pre&gt;&lt;code&gt; * * &lt;/code&gt;&lt;/pre&gt; * @memberOf Util * @block */ Blockly.JavaScript['physics_closest'] = function (block) { const source = Blockly.JavaScript.valueToCode(block, 'SOURCE', Blockly.JavaScript.ORDER_ATOMIC); const target = Blockly.JavaScript.valueToCode(block, 'TARGET', Blockly.JavaScript.ORDER_ATOMIC); return [`game.physics.arcade.closest(${source}, ${target})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * @deprecated * @method * @param * @returns {} * &lt;pre&gt;&lt;code&gt; * * &lt;/code&gt;&lt;/pre&gt; * @memberOf Util * @block */ Blockly.JavaScript['physics_farthest'] = function (block) { const source = Blockly.JavaScript.valueToCode(block, 'SOURCE', Blockly.JavaScript.ORDER_ATOMIC); const target = Blockly.JavaScript.valueToCode(block, 'TARGET', Blockly.JavaScript.ORDER_ATOMIC); return [`game.physics.arcade.farthest(${source}, ${target})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns the distance between the two objects, based on their x/y coordinates. * @method physics_distance_between * @param source object to check from * @param target object to check to * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.distanceBetween(source, target); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Util * @block */ Blockly.JavaScript['physics_distance_between'] = function (block) { const source = Blockly.JavaScript.valueToCode(block, 'SOURCE', Blockly.JavaScript.ORDER_ATOMIC); const target = Blockly.JavaScript.valueToCode(block, 'TARGET', Blockly.JavaScript.ORDER_ATOMIC); return [`game.physics.arcade.distanceBetween(${source}, ${target})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns the distance between an object and the mouse pointer. * @method physics_distance_to_pointer * @param source object to check from * @param pointer mouse pointer to check to * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.distanceToPointer(source, pointer); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Util * @block */ Blockly.JavaScript['physics_distance_to_pointer'] = function (block) { const source = Blockly.JavaScript.valueToCode(block, 'SOURCE', Blockly.JavaScript.ORDER_ATOMIC); const pointer = Blockly.JavaScript.valueToCode(block, 'POINTER', Blockly.JavaScript.ORDER_ATOMIC); return [`game.physics.arcade.distanceToPointer(${source}, ${pointer})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns the distance between an object and an x/y location in the game. * @method physics_distance_to_location * @param object object to check from * @param x {Number} x location to check * @param y {Number} y location to check * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.aracde.distanceToXY(object, x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Util * @block */ Blockly.JavaScript['physics_distance_to_location'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return [`game.physics.arcade.distanceToXY(${object}, ${x}, ${y})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; //endregion /** * @namespace Dynamics */ //region DYNAMICS /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_immovable'] = function (block) { const body = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('BODY'), Blockly.Variables.NAME_TYPE); const immovable = block.getFieldValue('IMMOVABLE') == 'TRUE'; return `${body}.body.immovable = ${immovable};\\n`; }; /** * Moves the first object to the second object at the given speed. Speed will be adjusted to reach the destination object within the given maximum time. If the destination object moves, the target location will not change. * @method move_to_object * @param object object to move * @param destinationObject object to move to * @param speed {Number} speed for the object to move at * @param maximumTime {Number} maximum amount of time to take to move * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.moveToObject(object, destinationObject, speed, maximumTime); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Dynamics * @block */ Blockly.JavaScript['move_to_object'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'GAMEOBJECT', Blockly.JavaScript.ORDER_ATOMIC); const destinationObject = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC); const maximumTime = Blockly.JavaScript.valueToCode(block, 'MAXIMUM_TIME', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.moveToObject(${object}, ${destinationObject}, ${speed}, ${maximumTime});\\n`; }; /** * Calculates, the acceleration based on rotation, and returns a point that contains the acceleration x value and the acceleration y value. * @method acceleration_from_rotation * @param rotation {Number} the angle in radians * @param speed {Number} the speed the object will move * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.accelerationFromRotation(rotation, speed) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Dynamics * @block */ Blockly.JavaScript['acceleration_from_rotation'] = function (block) { const rotation = Blockly.JavaScript.valueToCode(block, 'ROTATION', Blockly.JavaScript.ORDER_ATOMIC); const speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC); return [`game.physics.arcade.accelerationFromRotation(${rotation}, ${speed})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Move the object to the given location at the given speed, taking no longer than the maximum given time. Speed will be adjusted so the object reaches the location within the given time. * @method physics_move_to_location * @param object object to move * @param x {Number} x position of the location to move to * @param y {Number} y position of the location to move to * @param speed {Number} the speed the object will move at * @param time {Number} maximum time for the object to reach the location * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.moveToXY(object, x, y, speed, time); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Dynamics * @block */ Blockly.JavaScript['physics_move_to_location'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC); const time = Blockly.JavaScript.valueToCode(block, 'TIME', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.moveToXY(${object}, ${x}, ${y}, ${speed}, ${time});\\n`; }; /** * Move the object to the mouse pointer at the given speed, taking no longer than the maximum given time. Speed will be adjusted so the object reaches the location within the given time. * @method physics_move_to_pointer * @param object object to move * @param pointer the mouse pointer to move to * @param speed {Number} the speed the object will move at * @param time {Number} maximum time for the object to reach the location * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.moveToPointer(object, speed, pointer, time); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Dynamics * @block */ Blockly.JavaScript['physics_move_to_pointer'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC); const time = Blockly.JavaScript.valueToCode(block, 'TIME', Blockly.JavaScript.ORDER_ATOMIC); const pointer = Blockly.JavaScript.valueToCode(block, 'POINTER', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.moveToPointer(${object}, ${speed}, ${pointer}, ${time});\\n`; }; /** * Accelerates the object to the given location at the given speed, with the maximum given velocity. The object will start at the given speed, and accelerate up to the maximum velocity towards the location. * @method physics_accelerate_to_location * @param object object to move * @param x {Number} x position of the location to move to * @param y {Number} y position of the location to move to * @param speed {Number} the speed the object will move at * @param x_max {Number} the maximum velocity in the x direction the object can reach * @param y_max {Number} the maximum velocity in the y direction the object can reach * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.accelerateToXY(object, x, y, speed, x_max, y_max); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Dynamics * @block */ Blockly.JavaScript['physics_accelerate_to_location'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X_LOCATION', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y_LOCATION', Blockly.JavaScript.ORDER_ATOMIC); const speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC); const x_max = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y_max = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.accelerateToXY(${object}, ${x}, ${y}, ${speed}, ${x_max}, ${y_max});\\n`; }; /** * Accelerates the object to the mouse pointer at the given speed, with the maximum given velocity. The object will start at the given speed, and accelerate up to the maximum velocity towards the location. * @method physics_accelerate_to_pointer * @param object object to move * @param pointer the mouse pointer to move to * @param speed {Number} the speed the object will move at * @param x_max {Number} the maximum velocity in the x direction the object can reach * @param y_max {Number} the maximum velocity in the y direction the object can reach * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.accelerateToPointer(object, pointer, speed, x_max, y_max); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Dynamics * @block */ Blockly.JavaScript['physics_accelerate_to_pointer'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const pointer = Blockly.JavaScript.valueToCode(block, 'POINTER', Blockly.JavaScript.ORDER_ATOMIC); const speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC); const x_max = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y_max = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.accelerateToPointer(${object}, ${pointer}, ${speed}, ${x_max}, ${y_max});\\n`; }; /** * Accelerates the object to the given object's location at the given speed, with the maximum given velocity. The object will start at the given speed, and accelerate up to the maximum velocity towards the location. * @method physics_accelerate_to_object * @param object object to move * @param target the target object to move to * @param speed {Number} the speed the object will move at * @param x_max {Number} the maximum velocity in the x direction the object can reach * @param y_max {Number} the maximum velocity in the y direction the object can reach * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.accelerateToObject(object, target, speed, x_max, y_max); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Dynamics * @block */ Blockly.JavaScript['physics_accelerate_to_object'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const target = Blockly.JavaScript.valueToCode(block, 'TARGET', Blockly.JavaScript.ORDER_ATOMIC); const speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC); const x_max = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y_max = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.accelerateToObject(${object}, ${target}, ${speed}, ${x_max}, ${y_max});\\n`; }; //physics SET blocks /** * Assign the chosen Boolean field for the game's physics. * @method set_physics_boolean_field * @param field the field to set * @param value {Boolean} value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Dynamics * @block */ Blockly.JavaScript['set_physics_boolean_field'] = function (block) { const field = block.getFieldValue('FIELD'); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.${field} = ${value};\\n`; }; /** * Assigns the chosen point field for the game's physics. * @method set_physics_point_field * @param field the field to set * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.field.copyFrom(value); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Dynamics * @block */ Blockly.JavaScript['set_physics_point_field'] = function (block) { const field = block.getFieldValue('FIELD'); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.${field}.copyFrom(${value});\\n`; }; //physics GET blocks /** * Returns the chosen Boolean field value of the game's physics. * @method get_physics_boolean_field * @param field the field to get the value of * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Dynamics * @block */ /** * Returns the chosen point field value of the game's physics. * @method get_physics_point_field * @param field the field to get the value of * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Dynamics * @block */ Blockly.JavaScript['get_physics_boolean_field'] = Blockly.JavaScript['get_physics_point_field'] = function (block) { const field = block.getFieldValue('FIELD'); return [`game.physics.arcade.${field}`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; //endregion /** * @namespace Collision */ //region COLLISION /** * @deprecated * @param block * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['is_body_touching'] = function (block) { const body = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('BODY'), Blockly.Variables.NAME_TYPE); const direction = block.getFieldValue('DIRECTION'); return [`${body}.body.touching.${direction}`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @returns {String} * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['collide_with_world_bounds'] = function (block) { const variable_body = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('BODY'), Blockly.Variables.NAME_TYPE); const collide = block.getFieldValue('COLLIDE') == 'TRUE'; return `${variable_body}.body.collideWorldBounds = ${collide};\\n`; }; /** * Enables/disables collision between an object and the bounds of the world. * @method collide_with_world_bounds_vi * @param object object to set collision for * @param collide {Boolean} enables/disables the collision * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.collideWorldBounds = collide; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['collide_with_world_bounds_vi'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'BODY', Blockly.JavaScript.ORDER_ATOMIC); const collide = block.getFieldValue('COLLIDE') == 'TRUE'; return `${object}.body.collideWorldBounds = ${collide};\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['check_overlap'] = function (block) { const lhs = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('LHS'), Blockly.Variables.NAME_TYPE); const rhs = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('RHS'), Blockly.Variables.NAME_TYPE); const functionName = block.getFieldValue('NAME'); return `game.physics.arcade.overlap(${lhs}, ${rhs}, ${functionName}, null, this);\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['check_overlap_vi'] = function (block) { const lhs = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const rhs = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); const functionName = block.getFieldValue('NAME'); return `game.physics.arcade.overlap(${lhs}, ${rhs}, ${functionName}, null, this);\\n`; }; /** * Checks if two objects overlap, and calls the function if they are. No physics is applied. * @method check_overlap_vi_procedure_field * @param object1 first object to check * @param object2 second object to check * @param functionName function to call if the objects are overlapping * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.overlap(object1, object2, functionName); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['check_overlap_vi_procedure_field'] = function (block) { const object1 = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const object2 = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); const functionName = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('NAME'), Blockly.Procedures.NAME_TYPE); return `game.physics.arcade.overlap(${object1}, ${object2}, ${functionName}, null, this);\\n`; }; /** * Returns true/false if two objects are overlapping. * @method overlap_boolean * @param object1 first object to check * @param object2 second object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.overlap(object1, object2) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['overlap_boolean'] = function (block) { const object1 = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const object2 = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return [`game.physics.arcade.overlap(${object1}, ${object2})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Checks if two objects are colliding, separates them if they are, and calls the function. * @method collide_function_field * @param object1 first object to check * @param object2 second object to check * @param functionName function to call if the objects are colliding * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.collide(object1, object2, functionName); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['collide_function_field'] = function (block) { const object1 = Blockly.JavaScript.valueToCode(block, 'OBJECTA', Blockly.JavaScript.ORDER_ATOMIC); const object2 = Blockly.JavaScript.valueToCode(block, 'OBJECTB', Blockly.JavaScript.ORDER_ATOMIC); const functionName = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('NAME'), Blockly.Procedures.NAME_TYPE); return `game.physics.arcade.collide(${object1}, ${object2}, ${functionName});\\n`; }; /** * Checks if two objects are colliding, separates them if they are, and returns true/false. * @method collide_boolean * @param object1 first object to check * @param object2 second object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.collide(object1, object2) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['collide_boolean'] = function (block) { const object1 = Blockly.JavaScript.valueToCode(block, 'OBJECTA', Blockly.JavaScript.ORDER_ATOMIC); const object2 = Blockly.JavaScript.valueToCode(block, 'OBJECTB', Blockly.JavaScript.ORDER_ATOMIC); return [`game.physics.arcade.collide(${object1}, ${object2})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['collide'] = function (block) { const variable_lhs = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('LHS'), Blockly.Variables.NAME_TYPE); const variable_rhs = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('RHS'), Blockly.Variables.NAME_TYPE); return `game.physics.arcade.collide(${variable_lhs}, ${variable_rhs});\\n`; }; /** * Checks if two objects are colliding, and separates them if they are. * @method collide_vi * @param object1 first object to check * @param object2 second object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.collide(object1, object2); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['collide_vi'] = function (block) { const object1 = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const object2 = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.collide(${object1}, ${object2});\\n`; }; /** * Returns true if something is touching the object in the specified direction. * @method is_body_touching_vi * @param object object to check * @param direction direction to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.body.touching.direction * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['is_body_touching_vi'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'BODY', Blockly.JavaScript.ORDER_ATOMIC); const direction = block.getFieldValue('DIRECTION'); return [`${object}.body.touching.${direction}`, Blockly.JavaScript.ORDER_NONE]; }; /** * Enables/disables objects with physics enabled to collide with the world in the given direction. * @method check_collision * @param direction direction to set the property for * @param collide {Boolean} sets collision in the direction to true or false * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.checkCollision.direction = collide; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['check_collision'] = function (block) { var direction = block.getFieldValue('DIRECTION'); var collide = block.getFieldValue('COLLIDE') == 'TRUE'; return `game.physics.arcade.checkCollision.${direction} = ${collide};\\n`; }; /** * Returns a list of objects from the given group that are currently underneath the mouse pointer. * @method get_objects_under_pointer * @param pointer mouse pointer to check * @param group group to check * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.getObectsUnderPointer(pointer, group); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['get_objects_under_pointer'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); const pointer = Blockly.JavaScript.valueToCode(block, 'POINTER', Blockly.JavaScript.ORDER_ATOMIC); return [`game.physics.arcade.getObjectsUnderPointer(${pointer}, ${group})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * @deprecated * @method * @param * @returns {} * &lt;pre&gt;&lt;code&gt; * * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['collide_with_arrow_function'] = function (block) { const objectA = Blockly.JavaScript.valueToCode(block, 'OBJECTA', Blockly.JavaScript.ORDER_ATOMIC); const objectB = Blockly.JavaScript.valueToCode(block, 'OBJECTB', Blockly.JavaScript.ORDER_ATOMIC); const statements_callback = Blockly.JavaScript.statementToCode(block, 'CALLBACK');// TODO: Assemble JavaScript into code variable. return `game.physics.arcade.collide(${objectA}, ${objectB}, (${objectA}, ${objectB}) =&gt; { ${statements_callback} });\\n`; }; /** * Returns a list of objects from the group that are at the x/y location. * @method get_objects_at_location * @param group group to check * @param x {Number} x location to check * @param y {Number} y location to check * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.getObjectsAtLocation(x, y, group); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['get_objects_at_location'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return [`game.physics.arcade.getObjectsAtLocation(${x}, ${y}, ${group})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns a list of objects from the group that are at the x/y location, calling the given function on the ones that are there. * @method collision_get_objects_at_location_function * @param group group to check * @param x {Number} x location to check * @param y {Number} y location to check * @param functionName function to call * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.getObjectsAtLocation(x, y, group, functionName); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['collision_get_objects_at_location_function'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const functionName = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('NAME'), Blockly.Procedures.NAME_TYPE); return `game.physics.arcade.getObjectsAtLocation(${x}, ${y}, ${group}, ${functionName});\\n`; }; /** * Returns a Boolean if the two objects are intersecting. Checks for intersection of the object's bodies. * @method physics_intersects * @param lhs object to check * @param rhs object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * game.physics.arcade.intersects(lhs, rhs); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Collision * @block */ Blockly.JavaScript['physics_intersects'] = function (block) { const lhs = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const rhs = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return [`game.physics.arcade.intersects(${lhs}, ${rhs})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; //endregion /*Blockly.JavaScript['move_to_pointer'] = function (block) { const value_gameobject = Blockly.JavaScript.valueToCode(block, 'GAMEOBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value_speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC); const pointer = Blockly.JavaScript.valueToCode(block, 'POINTER', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.moveToPointer(${value_gameobject}, ${value_speed}, ${pointer});\\n`; };* &lt;/code&gt;&lt;/pre&gt; * @block */ /*Blockly.JavaScript['move_to_pointer_extended'] = function (block) { const gameobject = Blockly.JavaScript.valueToCode(block, 'GAMEOBJECT', Blockly.JavaScript.ORDER_ATOMIC); const speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC); const maximumTime = Blockly.JavaScript.valueToCode(block, 'MAXIMUM_TIME', Blockly.JavaScript.ORDER_ATOMIC); return `game.physics.arcade.moveToPointer(${gameobject}, ${speed}, game.input.mousePointer, ${maximumTime});\\n`; };* &lt;/code&gt;&lt;/pre&gt; * @block */ //endregion × Search results Close "},"phaser_camera.js.html":{"id":"phaser_camera.js.html","title":"Source: phaser_camera.js","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Source: phaser_camera.js /** * @namespace Camera */ //region CAMERA /** * Returns the game camera. * @method game_camera * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['game_camera'] = function () { return ['game.camera', Blockly.JavaScript.ORDER_NONE]; }; /** * Fades the screen to the colour over the given amount of time. * @method camera_fade * @param colour colour to fade the screen to * @param time {Number} how long to take to fade * @returns {} * &lt;pre&gt;&lt;code&gt; * function toHexColor(color) { return color.replace(&quot;#&quot;, &quot;0x&quot;); } game.camera.fade(toHexColorFunc(colour), time, true); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['camera_fade'] = function (block) { const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); const time = Blockly.JavaScript.valueToCode(block, 'TIME', Blockly.JavaScript.ORDER_ATOMIC); const toHexColorFunc = Blockly.JavaScript.provideFunction_( 'toHexColor', ['function ' + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + '(color) {', 'return color.replace(&quot;#&quot;, &quot;0x&quot;);', '}']); return `game.camera.fade(${toHexColorFunc}(${colour}), ${time}, true);\\n`; }; /** * Fills the game with the colour specified, then fades the colour away over the given amount of time. * @method camera_flash * @param colour colour to show * @param time {Number} how long to take to fade the colour away * @returns {} * &lt;pre&gt;&lt;code&gt; * function toHexColor(color) { return color.replace(&quot;#&quot;, &quot;0x&quot;); } game.camera.flash(toHexColorFunc(colour), time, true); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['camera_flash'] = function (block) { const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); const time = Blockly.JavaScript.valueToCode(block, 'TIME', Blockly.JavaScript.ORDER_ATOMIC); const toHexColorFunc = Blockly.JavaScript.provideFunction_( 'toHexColor', ['function ' + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + '(color) {', 'return color.replace(&quot;#&quot;, &quot;0x&quot;);', '}']); return `game.camera.flash(${toHexColorFunc}(${colour}), ${time}, true);\\n`; }; /** * Focus the camera on the given object. * @method camera_focus_on * @param object object to focus on * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera.focusOn(object); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['camera_focus_on'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `game.camera.focusOn(${object});\\n`; }; /** * Focus the camera on the given location. * @method camera_focus_on_xy * @param posX {Number} x position to focus on * @param posY {Number} y position to focus on * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera.focusOnXY(posX, posY); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['camera_focus_on_xy'] = function (block) { const posX = Blockly.JavaScript.valueToCode(block, 'POSX', Blockly.JavaScript.ORDER_ATOMIC); const posY = Blockly.JavaScript.valueToCode(block, 'POSY', Blockly.JavaScript.ORDER_ATOMIC); return `game.camera.focusOnXY(${posX}, ${posY});\\n`; }; /** * Resets the camera by making it focus back to 0,0 and unfollowing all objects. Also resets any camera effects. * @method camera_reset * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera.reset(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['camera_reset'] = function (block) { return `game.camera.reset();\\n`; }; /** * Resets any active camera effects. * @method camera_reset_fx * @return {} game.camera.resetFX(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['camera_reset_fx'] = function (block) { return `game.camera.resetFX();\\n`; }; /** * Updates the camera bounds to match the game world bounds. * @method camera_set_bounds_to_world * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera.setBoundsToWorld(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['camera_set_bounds_to_world'] = function (block) { return `game.camera.setBoundsToWorld();\\n`; }; /** * Sets the game camera position. * @method camera_set_position * @param posX {Number} x position for the camera * @param posY {Number} y position for the camera * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera.setPosition(posX, posY); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['camera_set_position'] = function (block) { const posX = Blockly.JavaScript.valueToCode(block, 'POSX', Blockly.JavaScript.ORDER_ATOMIC); const posY = Blockly.JavaScript.valueToCode(block, 'POSY', Blockly.JavaScript.ORDER_ATOMIC); return `game.camera.setPosition(${posX}, ${posY});\\n`; }; /** * Sets the size of the camera viewing rectangle. * @method camera_set_size * @param width {Number} the width of the camera view port * @param height {Number} the height of the camera view port * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera.setSize(width, height); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['camera_set_size'] = function (block) { const width = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_ATOMIC); const height = Blockly.JavaScript.valueToCode(block, 'HEIGHT', Blockly.JavaScript.ORDER_ATOMIC); return `game.camera.setSize(${width}, ${height});\\n`; }; /** * Creates a camera shake effect by moving the camera randomly at the given intensity for the given amount of time. * @method camera_shake * @param intensity {Number} how much the camera should move while shaking * @param direction which direction the camera should shake * @param duration {Number} how long the camera should shake * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera.shake(intensity, duration, true, Phaser.Camera.direction); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['camera_shake'] = function (block) { const intensity = Blockly.JavaScript.valueToCode(block, 'INTENSITY', Blockly.JavaScript.ORDER_ATOMIC); const direction = block.getFieldValue('DIRECTION'); const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC); return `game.camera.shake(${intensity}, ${duration}, true, Phaser.Camera.${direction});\\n`; }; /** * Stops the camera from following all objects. * @method camera_unfollow * @returns {} * &lt;pre&gt;&lt;code&gt; * game.camera.unfollow(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Camera * @block */ Blockly.JavaScript['camera_unfollow'] = function (block) { return `game.camera.unfollow();\\n`; }; //endregion × Search results Close "},"phaser_geometry.js.html":{"id":"phaser_geometry.js.html","title":"Source: phaser_geometry.js","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Source: phaser_geometry.js /** * @namespace Rectangle */ //region RECTANGLE /** * Creates a rectangle with the given properties. * @method rectangle_create * @param x {Number} x coordinate for the new rectangle * @param y {Number} y coordinate for the new rectangle * @param width {Number} width of the rectangle * @param height {Number} height of the rectangle * @returns {} * &lt;pre&gt;&lt;code&gt; * new Phaser.Rectangle(x, y, width, height) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Rectangle * @block */ Blockly.JavaScript['rectangle_create'] = function (block) { const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || 0; const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || 0; const width = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_ATOMIC) || 0; const height = Blockly.JavaScript.valueToCode(block, 'HEIGHT', Blockly.JavaScript.ORDER_ATOMIC) || 0; return [`new Phaser.Rectangle(${x}, ${y}, ${width}, ${height})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns true/false if the two rectangles intersect. * @method rectangle_intersects * @param rectA first rectangle to check * @param rectB second rectangle to check * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Rectangle.intersects(rectA, rectB) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Rectangle * @block */ Blockly.JavaScript['rectangle_intersects'] = function (block) { const rectA = Blockly.JavaScript.valueToCode(block, 'RECT_A', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const rectB = Blockly.JavaScript.valueToCode(block, 'RECT_B', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; return [`Phaser.Rectangle.intersects(${rectA}, ${rectB})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns the chosen numeric field value of the rectangle. * @method rectangle_get_numeric_field * @param object object to get values from * @param field the field to get values of * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Rectangle * @block */ /** * Returns the chosen point field value of the rectangle. * @method rectangle_get_point_field * @param object object to get values from * @param field the field to get values of * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Rectangle * @block */ Blockly.JavaScript['rectangle_get_numeric_field'] = Blockly.JavaScript['rectangle_get_point_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const field = block.getFieldValue('FIELD'); return [`${object}.${field}`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Assign the chosen numeric field of the rectangle. * @method rectangle_set_numeric_field * @param object object to set the value for * @param field the field to set * @param value {Number} value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Rectangle * @block */ Blockly.JavaScript['rectangle_set_numeric_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('FIELD'); return `${object}.${field} = ${value};\\n`; }; /** * Assign the chosen point field of the rectangle. * @method rectangle_set_point_field * @param object object to set the point for * @param field the field to set * @param point point to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field.copyFrom(point); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Rectangle * @block */ Blockly.JavaScript['rectangle_set_point_field'] = setPointField; /** * Returns true/false if the rectangle contains the point. * @method rectangle_contains_point * @param rectangle rectangle to check * @param point point to check * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Rectangle.containsPoint(rectangle, point) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Rectangle * @block */ Blockly.JavaScript['rectangle_contains_point'] = function (block) { const rectangle = Blockly.JavaScript.valueToCode(block, 'RECTANGLE', Blockly.JavaScript.ORDER_ATOMIC); const point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Rectangle.containsPoint(${rectangle}, ${point})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns true/false if the rectangle contains the given coordinates. * @method rectangle_contains * @param rectangle rectangle to check * @param x {Number} x coordinate to check * @param y {Number} y coordinate to check * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Rectangle.contains(rectangle, x, y) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Rectangle * @block */ Blockly.JavaScript['rectangle_contains'] = function (block) { const rectangle = Blockly.JavaScript.valueToCode(block, 'RECTANGLE', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Rectangle.contains(${rectangle}, ${x}, ${y})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns true/false if one rectangle is fulling contained within another. * @method rectangle_contains_rect * @param rectangle_a the first rectangle to check * @param rectangle_b the second rectangle to check * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Rectangle.containsRect(rectangle_a, rectangle_b) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Rectangle * @block */ Blockly.JavaScript['rectangle_contains_rect'] = function (block) { const rectangle_a = Blockly.JavaScript.valueToCode(block, 'RECTANGLE_A', Blockly.JavaScript.ORDER_ATOMIC); const rectangle_b = Blockly.JavaScript.valueToCode(block, 'RECTANGLE_B', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Rectangle.containsRect(${rectangle_a}, ${rectangle_b})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns a new rectangle with the same x, y, width, and height properties of the original. * @method rectangle_clone * @param rectangle rectangle to clone * @returns {} * &lt;pre&gt;&lt;code&gt; * rectangle.clone() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Rectangle * @block */ Blockly.JavaScript['rectangle_clone'] = function (block) { const rectangle = Blockly.JavaScript.valueToCode(block, 'RECTANGLE', Blockly.JavaScript.ORDER_ATOMIC); // return [`Phaser.Rectangle.clone(${rectangle})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; return [`${rectangle}.clone()`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns a random x/y coordinate point from the rectangle. * @method rectangle_random * @param rectangle rectangle to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * rectangle.random() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Rectangle * @block */ Blockly.JavaScript['rectangle_random'] = function (block) { const rectangle = Blockly.JavaScript.valueToCode(block, 'RECTANGLE', Blockly.JavaScript.ORDER_ATOMIC); return [`${rectangle}.random()`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; //endregion /** * @namespace Point */ //region POINT /** * Returns a point from the given x/y values. * @method point_create * @param x {Number} x value for the point * @param y {Number} y value for the point * @returns {} * &lt;pre&gt;&lt;code&gt; * new Phaser.Point(x, y) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['point_create'] = function (block) { const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || 0; const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || 0; return [`new Phaser.Point(${x}, ${y})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns the x or y value of the point. * @method point_get_element * @param element which value to return * @param point point to get the value from * @returns {} * &lt;pre&gt;&lt;code&gt; * point.element * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['point_get_element'] = function (block) { const element = block.getFieldValue('ELEMENT'); const point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); return [`${point}.${element}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Assigns the x or y value of the point to a number. * @method point_set_element * @param element which value to set * @param point point to set the value for * @param value {Number} value to set the element to * @returns {} * &lt;pre&gt;&lt;code&gt; * point.element = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['point_set_element'] = function (block) { const element = block.getFieldValue('ELEMENT'); const point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.${element} = ${value};\\n`; }; /** * Sets the magnitude of the point to a number. * @method point_set_magnitude * @param point point to set the magnitude for * @param value {Number} value to set the magnitude to * @returns {} * &lt;pre&gt;&lt;code&gt; * point.setMagnitude(value); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['point_set_magnitude'] = function (block) { const point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.setMagnitude(${value});\\n`; }; /** * Adds the coordinates of two points and returns a new point with the result. * @method points_add * @param pointA first point to add * @param pointB second point to add * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.add(pointA, pointB) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_add'] = function (block) { const pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const pointB = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.add(${pointA}, ${pointB})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Subtracts the coordinates of two points and returns a new point with the result. * @method points_subtract * @param pointA first point to subtract * @param pointB second point to subtract * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.subtract(pointA, pointB) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_subtract'] = function (block) { const pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const pointB = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.subtract(${pointA}, ${pointB})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Calculates the angle between two points and returns the result. * @method points_angle_between * @param pointA first angle to calculate * @param pointB second angle to calculate * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.angle(pointA, pointB) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_angle_between'] = function (block) { const pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const pointB = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.angle(${pointA}, ${pointB})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Calculates the distance between two points and returns the result. * @method points_distance * @param pointA first angle to calculate * @param pointB second angle to calculate * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.distance(pointA, pointB) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_distance'] = function (block) { const pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const pointB = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.distance(${pointA}, ${pointB})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Divides the coordinates of two points and returns a new point with the result. * @method points_divide * @param pointA first point to divide * @param pointB second point to divide * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.divide(pointA, pointB) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_divide'] = function (block) { const pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const pointB = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.divide(${pointA}, ${pointB})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns true/false if one point has the same x/y values as another. * @method points_equals * @param pointA first point to check * @param pointB second point to check * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.equals(pointA, pointB) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_equals'] = function (block) { const pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const pointB = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.equals(${pointA}, ${pointB})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Interpolates the two points based on the percent value between 0 and 1. * @method points_interpolate * @param pointA first point * @param pointB second point * @param f {Number} the level of interpolation between the two points * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.interpolate(pointA, pointB, f) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_interpolate'] = function (block) { const pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const pointB = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); const f = Blockly.JavaScript.valueToCode(block, 'F', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.interpolate(${pointA}, ${pointB}, ${f})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Multiplies the coordinates of two points and returns a new point with the result. * @method points_multiply * @param pointA first point to multiply * @param pointB second point to multiply * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.multiply(pointA, pointB) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_multiply'] = function (block) { const pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); const pointB = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.multiply(${pointA}, ${pointB})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Creates a new point with negative values of the original point. * @method points_negate * @param pointA point to get the values from * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.negative(pointA) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_negate'] = function (block) { const pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.negative(${pointA})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns a new point of the normalized values of the original. * @method points_normalize * @param pointA point to normalize * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.normalize(pointA) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_normalize'] = function (block) { const pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.normalize(${pointA})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns a new point with the perpendicular vector to the original point. * @method points_perpendicular * @param pointA point to get the vector from * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.perp(pointA) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_perpendicular'] = function (block) { const pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.perp(${pointA})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns a new point with the centroid of the list of points. * @method points_centroid * @param array {Array} list of points to calculate the centroid from * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Point.centroid(array) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_centroid'] = function (block) { var array = Blockly.JavaScript.valueToCode(block, 'ARRAY', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.Point.centroid(${array})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Clamps the point object values to be between the given minimum and maximum. * @method points_clamp * @param point point to clamp * @param min {Number} the minimum value to clamp the point to * @param max {Number} the maximum value to clamp the point to * @returns {} * &lt;pre&gt;&lt;code&gt; * point.clamp(min, max); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_clamp'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); var min = Blockly.JavaScript.valueToCode(block, 'MIN', Blockly.JavaScript.ORDER_ATOMIC); var max = Blockly.JavaScript.valueToCode(block, 'MAX', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.clamp(${min}, ${max});\\n`; }; /** * Clamp the point object x value to be between the given minimum and maximum. * @method points_clamp_x * @param point point to clamp * @param min {Number} the minimum value to clamp the value to * @param max {Number} the maximum value to lcmap the value to * @returns {} * &lt;pre&gt;&lt;code&gt; * point.clampX(min, max); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_clamp_x'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); var min = Blockly.JavaScript.valueToCode(block, 'MIN', Blockly.JavaScript.ORDER_ATOMIC); var max = Blockly.JavaScript.valueToCode(block, 'MAX', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.clampX(${min}, ${max});\\n`; }; /** * Clamp the point object y value to be between the given minimum and maximum. * @method points_clamp_y * @param point point to clamp * @param min {Number} the minimum value to clamp the value to * @param max {Number} the maximum value to lcmap the value to * @returns {} * &lt;pre&gt;&lt;code&gt; * point.clampY(min, max); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_clamp_y'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); var min = Blockly.JavaScript.valueToCode(block, 'MIN', Blockly.JavaScript.ORDER_ATOMIC); var max = Blockly.JavaScript.valueToCode(block, 'MAX', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.clampY(${min}, ${max});\\n`; }; /** * Returns a new point with the same properties as the original point. * @method points_clone * @param point point to clone * @returns {} * &lt;pre&gt;&lt;code&gt; * point.clone() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_clone'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); return [`${point}.clone()`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Copies values from one point to another, overwriting the original values. * @method points_copy_from * @param source point to get the values from * @param target point to copy the values to * @returns {} * &lt;pre&gt;&lt;code&gt; * target.copyFrom(source); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_copy_from'] = function (block) { var source = Blockly.JavaScript.valueToCode(block, 'SOURCE', Blockly.JavaScript.ORDER_ATOMIC); var target = Blockly.JavaScript.valueToCode(block, 'TARGET', Blockly.JavaScript.ORDER_ATOMIC); return `${target}.copyFrom(${source});\\n`; }; /** * Calculates the cross product of two points and returns the result. * @method points_cross * @param pointA left-hand side * @param pointB right-hand side * @returns {} * &lt;pre&gt;&lt;code&gt; * pointA.cross(pointB) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_cross'] = function (block) { var pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); var pointB = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return [`${pointA}.cross(${pointB})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Calculates the dot product of two points and returns the result. * @method points_dot * @param pointA left-hand side * @param pointB right-hand side * @returns {} * &lt;pre&gt;&lt;code&gt; * pointA.dot(pointB) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_dot'] = function (block) { var pointA = Blockly.JavaScript.valueToCode(block, 'LHS', Blockly.JavaScript.ORDER_ATOMIC); var pointB = Blockly.JavaScript.valueToCode(block, 'RHS', Blockly.JavaScript.ORDER_ATOMIC); return [`${pointA}.dot(${pointB})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Adds the given x and y values to the point. * @method points_add_member * @param point point to add values to * @param x {Number} x value to add to the point * @param y {Number} y value to add to the point * @returns {} * &lt;pre&gt;&lt;code&gt; * point.add(x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_add_member'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); var x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); var y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.add(${x}, ${y});\\n`; }; /** * Subtracts the given x and y values from the point. * @method points_subtract_member * @param point point to subtract values from * @param x {Number} x value to subtract from the point * @param y {Number} y value to subtract from the point * @returns {} * &lt;pre&gt;&lt;code&gt; * point.subtract(x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_subtract_member'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); var x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); var y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.subtract(${x}, ${y});\\n`; }; /** * Divides the point values by the given x and y values. * @method points_divide_member * @param point point to divide * @param x {Number} x value to divide the point by * @param y {Number} y value to divide the point by * @returns {} * &lt;pre&gt;&lt;code&gt; * point.divide(x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_divide_member'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); var x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); var y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.divide(${x}, ${y});\\n`; }; /** * Multiplies the point values by the given x and y values. * @method points_multiply_member * @param point point to multiply * @param x {Number} x value to multiply the point by * @param y {Number} y value to multiply the point by * @returns {} * &lt;pre&gt;&lt;code&gt; * point.multiply(x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_multiply_member'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); var x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); var y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.multiply(${x}, ${y});\\n`; }; /** * Applies Math.ceil() to the x and y values of the point. * @method points_ceil * @param point point to change the values of * @returns {} * &lt;pre&gt;&lt;code&gt; * point.ceil(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_ceil'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.ceil();\\n`; }; /** * Applies Math.floor() to the x and y values of the point. * @method points_floor * @param point point to change the values of * @returns {} * &lt;pre&gt;&lt;code&gt; * point.floor(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_floor'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.floor();\\n`; }; /** * Returns the length of the point object. * @method points_get_magnitude * @param point point to get the magnitude of * @returns {} * &lt;pre&gt;&lt;code&gt; * point.getMagnitude() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_get_magnitude'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); return [`${point}.getMagnitude()`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns the length squared of the point object. * @method points_get_magnitude_squared * @param point point to get the magnitude squared of * @returns {} * &lt;pre&gt;&lt;code&gt; * point.getMagnitudeSq() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_get_magnitude_squared'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); return [`${point}.getMagnitudeSq()`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Inverts the x and y values of the point. * @method points_invert * @param point point to invert * @returns {} * &lt;pre&gt;&lt;code&gt; * point.invert(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_invert'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.invert();\\n`; }; /** * Returns true/false if the point has the values 0,0. * @method points_is_zero * @param point point to check * @returns {} * &lt;pre&gt;&lt;code&gt; * point.isZero() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_is_zero'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); return [`${point}.isZero()`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Alters the point so it's magnitude is no more than the given maximum value. * @method points_limit * @param point point to change * @param max {Number} the value to set the maximum to * @returns {} * &lt;pre&gt;&lt;code&gt; * point.limit(max); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_limit'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); var max = Blockly.JavaScript.valueToCode(block, 'MAX', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.limit(${max});\\n`; }; /** * Sets the x and y values of hte point based on the given polar coordinate. * @method points_set_to_polar * @param point point to change the values of * @param degrees {Number} degrees of the polar coordinate * @param radius {Number} radius of the polar coordinate * @returns {} * &lt;pre&gt;&lt;code&gt; * point.setToPolar(degrees, radius, true); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Point * @block */ Blockly.JavaScript['points_set_to_polar'] = function (block) { var point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); var degrees = Blockly.JavaScript.valueToCode(block, 'DEGREES', Blockly.JavaScript.ORDER_ATOMIC); var radius = Blockly.JavaScript.valueToCode(block, 'RADIUS', Blockly.JavaScript.ORDER_ATOMIC); return `${point}.setToPolar(${degrees}, ${radius}, true);\\n`; }; //endregion /** * @namespace Circle */ //region CIRCLE /** * Returns a circle with the given properties. * @method circle_create * @param x {Number} x coordinate to create the circle at * @param y {Number} y coordinate to create the circle at * @param diameter {Number} diameter of the circle * @returns {} * &lt;pre&gt;&lt;code&gt; * new Phaser.Circle(x, y, diameter) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Circle * @block */ Blockly.JavaScript['circle_create'] = function (block) { const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || 0; const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || 0; const diameter = Blockly.JavaScript.valueToCode(block, 'DIAMETER', Blockly.JavaScript.ORDER_ATOMIC) || 0; return [`new Phaser.Circle(${x}, ${y}, ${diameter})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns the chosen numeric field value of the circle. * @method circle_get_numeric_field * @param object object to get values from * @param field the field to get values of * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Circle * @block */ Blockly.JavaScript['circle_get_numeric_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const field = block.getFieldValue('FIELD'); return [`${object}.${field}`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Assign the chosen numeric field of the circle. * @method circle_set_numeric_field * @param object object to set the value for * @param field the field to set * @param value {Number} value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Circle * @block */ Blockly.JavaScript['circle_set_numeric_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('FIELD'); return `${object}.${field} = ${value};\\n`; }; /** * Returns true/false if the two circle objects intersect, determined by the radius distances between the two. * @method circle_intersects * @param circle_a first circle to check * @param circle_b second circle to check * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Circle.intersects(circle_a, circle_b) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Circle * @block */ Blockly.JavaScript['circle_intersects'] = function (block) { const circle_a = Blockly.JavaScript.valueToCode(block, 'CIRCLE_A', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const circle_b = Blockly.JavaScript.valueToCode(block, 'CIRCLE_B', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; return [`Phaser.Circle.intersects(${circle_a}, ${circle_b})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns true/false if the circle and rectangle objects intersect. * @method circle_intersects_rectangle * @param circle circle to check * @param rectangle rectangle to check * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Circle.intersectsRectangle(circle, rectangle) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Circle * @block */ Blockly.JavaScript['circle_intersects_rectangle'] = function (block) { const circle = Blockly.JavaScript.valueToCode(block, 'CIRCLE', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const rectangle = Blockly.JavaScript.valueToCode(block, 'RECTANGLE', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; return [`Phaser.Circle.intersectsRectangle(${circle}, ${rectangle})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns a new circle object with the same properties as the original. * @method circle_clone * @param circle circle to clone * @returns {} * &lt;pre&gt;&lt;code&gt; * circle.clone() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Circle * @block */ Blockly.JavaScript['circle_clone'] = function (block) { const circle = Blockly.JavaScript.valueToCode(block, 'CIRCLE', Blockly.JavaScript.ORDER_ATOMIC); return [`${circle}.clone()`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns true/false if the given x/y coordinate can be found within the circle. * @method circle_contains * @param circle circle to check * @param x {Number} the x value to check * @param y {Number} the y value to check * @returns {} * &lt;pre&gt;&lt;code&gt; * circle.contains(x, y) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Circle * @block */ Blockly.JavaScript['circle_contains'] = function (block) { const circle = Blockly.JavaScript.valueToCode(block, 'CIRCLE', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return [`${circle}.contains(${x}, ${y})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns a point containing random values of x and y found within the circle. * @method cirlce_random * @param circle circle to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * circle.random() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Circle * @block */ Blockly.JavaScript['circle_random'] = function (block) { const circle = Blockly.JavaScript.valueToCode(block, 'CIRCLE', Blockly.JavaScript.ORDER_ATOMIC); return [`${circle}.random()`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns the circumference of the circle. * @method circle_circumference * @param circle circle to get circumference of * @returns {} * &lt;pre&gt;&lt;code&gt; * circle.circumference() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Circle * @block */ Blockly.JavaScript['circle_circumference'] = function (block) { const circle = Blockly.JavaScript.valueToCode(block, 'CIRCLE', Blockly.JavaScript.ORDER_ATOMIC); return [`${circle}.circumference()`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns a point containing the coordinates of the point on the circumference of the circle based on the given angle. * @method circle_circumference_point * @param circle circle to get values from * @param degrees {Number} angle to get the point at * @returns {} * &lt;pre&gt;&lt;code&gt; * circle_circumference_point * &lt;/code&gt;&lt;/pre&gt; * @memberOf Circle * @block */ Blockly.JavaScript['circle_circumference_point'] = function (block) { const circle = Blockly.JavaScript.valueToCode(block, 'CIRCLE', Blockly.JavaScript.ORDER_ATOMIC); const degrees = Blockly.JavaScript.valueToCode(block, 'DEGREES', Blockly.JavaScript.ORDER_ATOMIC); return [`${circle}.circumferencePoint(${degrees}, true)`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; //endregion × Search results Close "},"phaser_utility.js.html":{"id":"phaser_utility.js.html","title":"Source: phaser_utility.js","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Source: phaser_utility.js /** * @namespace Debug */ //region DEBUG /** * Enables stepping through the game loop one frame at a time. Must use game.step() * @method enable_step * @returns {} * &lt;pre&gt;&lt;code&gt; * game.enableStep(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['enable_step'] = function (block) { return `game.enableStep();\\n`; }; /** * Disables stepping through the game loop. * @method disable_step * @returns {} * &lt;pre&gt;&lt;code&gt; * game.disableStep(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['disable_step'] = function (block) { return `game.disableStep();\\n`; }; /** * Steps through the game loop one frame at a time. * @method step * @returns {} * &lt;pre&gt;&lt;code&gt; * game.step(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['step'] = function (block) { return `game.step();\\n`; }; /** * Renders a geometry object. * @method debug_geom * @param object object to render * @param colour colour to render the object with * @param filled {Boolean} whether or not to leave the object filled or stroked * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.geom(object, colour, filled); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_geom'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); const filled = block.getFieldValue('FILLED') == 'TRUE'; return `game.debug.geom(${object}, ${colour}, ${filled});\\n`; }; /** * Display all information about the sprite object and it's properties. * @method debug_sprite * @param object object to display information about * @param x {Number} x coordiante to display the information at * @param y {Number} y coordinate to display the information at * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.spriteInfo(object, x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_sprite'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X_VAL', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y_VAL', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.spriteInfo(${object}, ${x}, ${y});\\n`; }; /*Blockly.JavaScript['debug_body_info'] = function(block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.bodyInfo(${object},${0},${20});\\n`; };* &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ /** * * @method Display all information about the object's physics body. * @param object object to display body information of * @param x {Number} x coordiante to display the information at * @param y {Number} y coordinate to display the information at * @param colour colour to display the information with * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.bodyInfo(object, x, y, colour); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_body_info'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.bodyInfo(${object}, ${x}, ${y}, ${colour});\\n`; }; /** * Makes the physics body for the object visible. * @method debug_body_render * @param object object to display the body of * @param colour colour to display the body with * @param filled {Boolean} whether or not the body should display as stroked or filled * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.body(object, colour, filled); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_body_render'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'BODY', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); const filled = block.getFieldValue('FILLED') == 'TRUE'; return `game.debug.body(${object}, ${colour}, ${filled});\\n`; }; /** * Makes the game camera target and deadzone visible. * @method debug_camera * @param camera camera to display properties of * @param colour colour to display the properties with * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.camera(camera, colour); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_camera'] = function (block) { const camera = Blockly.JavaScript.valueToCode(block, 'CAMERA', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.camera(${camera},${colour});\\n`; }; /** * Displays information about the camera at the given location. * @method debug_camera_info * @param x {Number} x coordinate to display the information at * @param y {Number} y coordinate to display the information at * @param colour colour to display the information with * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.cameraInfo(game.camera, x, y, colour); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_camera_info'] = function (block) { const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.cameraInfo(${`game.camera`}, ${x}, ${y}, ${colour});\\n`; }; /** * Display information about the mouse at the given location. * @method debug_input_info * @param x {Number} x coordinate to display the information at * @param y {Number} y coordinate to display the information at * @param colour colour to display the information with * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.inputInfo(x, y, colour); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_input_info'] = function (block) { const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.inputInfo(${x}, ${y}, ${colour});\\n`; }; /** * Display information about the key at the given location. * @method debug_key * @param dropdown_key key to display information of * @param x {Number} x coordinate to display the information at * @param y {Number} y coordinate to display the information at * @param colour colour to display the information with * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.key(game.input.keyboard.addKey(Phaser.Keyboard.dropdown_key), x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_key'] = function (block) { const dropdown_key = block.getFieldValue('KEY'); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.key(game.input.keyboard.addKey(Phaser.Keyboard.${dropdown_key}), ${x}, ${y});\\n`;//, ${colour});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['debug_physics_group'] = function (block) { const group = Blockly.JavaScript.valueToCode(block, 'GROUP', Blockly.JavaScript.ORDER_ATOMIC); const check_exists = block.getFieldValue('CHECK_EXISTS') == 'TRUE'; //return `${group}.destroy(${check_exists});\\n`; return `game.debug.physicsGroup(${group});\\n`;//, ${&quot;'#73ff5c'&quot;}, ${true}, ${check_exists});\\n`; }; /** * Display a rectangle with the given properties. * @method debug_rectangle * @param rect rectangle to display * @param colour colour to display the rectangle with * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.rectangle(rect, colour); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_rectangle'] = function (block) { const rect = Blockly.JavaScript.valueToCode(block, 'RECT', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.rectangle(${rect},${colour});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['debug_sound'] = function (block) { const x_pos = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y_pos = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.sound(${x_pos}, ${y_pos}, ${colour});\\n`; }; /** * Display information about the sound at the given location. * @method debug_sound_info * @param sound sound to display information of * @param x {Number} x coordinate to display the information at * @param y {Number} y coordinate to display the information at * @param colour colour to display the information with * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.soundInfo(sound, x, y, colour); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_sound_info'] = function (block) { const sound = Blockly.JavaScript.valueToCode(block, 'SOUND', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.soundInfo(${sound}, ${x}, ${y}, ${colour});\\n`; }; /** * Display the sprite object's coordinates at the given location. * @method debug_sprite_coords * @param sprite sprite to display the coordinates of * @param x {Number} x coordinate to display the information at * @param y {Number} y coordinate to display the information at * @parm colour colour to display the coordinates with * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.spriteCoords(sprite, x, y, colour); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_sprite_coords'] = function (block) { const sprite = Blockly.JavaScript.valueToCode(block, 'SPRITE', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.spriteCoords(${sprite}, ${x}, ${y}, ${colour});\\n`; }; /** * Display information about the sprite object at the given location. * @method debug_sprite_info * @param sprite sprite to display information of * @param x {Number} x coordinate to display the information at * @param y {Number} y coordinate to display the information at * @parm colour colour to display the information with * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.spriteInfo(sprite, x, y, colour); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_sprite_info'] = function (block) { const sprite = Blockly.JavaScript.valueToCode(block, 'SPRITE', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.spriteInfo(${sprite}, ${x}, ${y}, ${colour});\\n`; }; /** * Display the text at the given location. * @method debug_text * @param text text to display * @param x {Number} x coordinate to display the information at * @param y {Number} y coordinate to display the information at * @param colour colour to display the information with * @returns {} * &lt;pre&gt;&lt;code&gt; * game.debug.text(text, x, y, colour); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Debug * @block */ Blockly.JavaScript['debug_text'] = function (block) { const text = Blockly.JavaScript.valueToCode(block, 'TEXT', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const colour = Blockly.JavaScript.valueToCode(block, 'COLOUR', Blockly.JavaScript.ORDER_ATOMIC); return `game.debug.text(${text}, ${x}, ${y}, ${colour});\\n`; }; //endregion /** * @namespace Math */ //region MATH /** * Converts the given degrees to radians and returns the result. * @method math_deg_to_rad * @param degrees {Number} the number of degrees to convert to radians. * @returns {} * &lt;pre&gt;&lt;code&gt; * game.math.degToRad(degrees) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Math * @block */ Blockly.JavaScript['math_deg_to_rad'] = function (block) { const degrees = Blockly.JavaScript.valueToCode(block, 'DEGREES', Blockly.JavaScript.ORDER_ATOMIC); return [`game.math.degToRad(${degrees})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Converts the given radians to degrees and returns the result. * @method math_rad_to_deg * @param radians {Number} the number of radians to convert to degrees * @returns {} * &lt;pre&gt;&lt;code&gt; * game.math.radToDeg(radians) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Math * @block */ Blockly.JavaScript['math_rad_to_deg'] = function (block) { const radians = Blockly.JavaScript.valueToCode(block, 'RADIANS', Blockly.JavaScript.ORDER_ATOMIC); return [`game.math.radToDeg(${radians})`, Blockly.JavaScript.ORDER_NONE]; }; //endregion /** * @namespace PhaserList */ //region PHASERLIST /** * Finds the value in the list that is closest to the given value * @method list_find_closest * @param value {Number} the search value * @param array the list to search * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.ArrayUtils.findClosest(value, array) * &lt;/code&gt;&lt;/pre&gt; * @memberOf PhaserList * @block */ Blockly.JavaScript['list_find_closest'] = function (block) { const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); const array = Blockly.JavaScript.valueToCode(block, 'ARRAY', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.ArrayUtils.findClosest(${value}, ${array})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns a randomly selected item from the given list. * @method list_get_random * @param array list to get the value from * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.ArrayUtils.getRandomItem(array) * &lt;/code&gt;&lt;/pre&gt; * @memberOf PhaserList * @block */ Blockly.JavaScript['list_get_random'] = function (block) { const array = Blockly.JavaScript.valueToCode(block, 'ARRAY', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.ArrayUtils.getRandomItem(${array})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Creates and returns a list with every number between the given parameters. * @method number_list * @param start {Number} the minimum value the list starts with * @param end {Number} the maximum value the list contains * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.ArrayUtils.numberArray(start, end) * &lt;/code&gt;&lt;/pre&gt; * @memberOf PhaserList * @block */ Blockly.JavaScript['number_list'] = function (block) { const start = Blockly.JavaScript.valueToCode(block, 'START', Blockly.JavaScript.ORDER_ATOMIC); const end = Blockly.JavaScript.valueToCode(block, 'END', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.ArrayUtils.numberArray(${start}, ${end})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Creates and returns a list starting with the min value, stepping by the given value, and stopping at the max value. * @method number_list_step * @param start {Number} the minimum value the list starts with * @param end {Number} the maximum value the list starts with * @param step {Number} the value to incremement/decrement by * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.ArrayUtils.numberArrayStep(start, end, step) * &lt;/code&gt;&lt;/pre&gt; * @memberOf PhaserList * @block */ Blockly.JavaScript['number_list_step'] = function (block) { const start = Blockly.JavaScript.valueToCode(block, 'START', Blockly.JavaScript.ORDER_ATOMIC); const end = Blockly.JavaScript.valueToCode(block, 'END', Blockly.JavaScript.ORDER_ATOMIC); const step = Blockly.JavaScript.valueToCode(block, 'STEP', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.ArrayUtils.numberArrayStep(${start}, ${end}, ${step})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns a random item and removes it from the list. * @method list_remove_random_item * @param array list to get the item from * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.ArrayUtils.removeRandomItem(array) * &lt;/code&gt;&lt;/pre&gt; * @memberOf PhaserList * @block */ Blockly.JavaScript['list_remove_random_item'] = function (block) { const array = Blockly.JavaScript.valueToCode(block, 'ARRAY', Blockly.JavaScript.ORDER_ATOMIC); return [`Phaser.ArrayUtils.removeRandomItem(${array})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Shuffles the contents of the list by changing the positions of all items. * @method list_shuffle * @param array list to shuffle * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.ArrayUtils.shuffle(array); * &lt;/code&gt;&lt;/pre&gt; * @memberOf PhaserList * @block */ Blockly.JavaScript['list_shuffle'] = function (block) { const array = Blockly.JavaScript.valueToCode(block, 'ARRAY', Blockly.JavaScript.ORDER_ATOMIC); return `Phaser.ArrayUtils.shuffle(${array});\\n`; }; //endregion /** * @namespace Random */ //region RANDOMISATION /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['create_random_generator'] = function (block) { return [`new Phaser.RandomDataGenerator([new Date().getTime()])`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['create_random_generator_seeded'] = function (block) { const seed = Blockly.JavaScript.valueToCode(block, 'SEED', Blockly.JavaScript.ORDER_ATOMIC); return [`new Phaser.RandomDataGenerator(${seed})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns a random angle between -180 and 180. * @method random_angle * @returns {} * &lt;pre&gt;&lt;code&gt; * game.rnd.angle() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Random * @block */ Blockly.JavaScript['random_angle'] = function (block) { return [`game.rnd.angle()`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns a random item from the list. * @method random_pick * @param array list to pick from * @returns {} * &lt;pre&gt;&lt;code&gt; * game.rnd.pick(array) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Random * @block */ Blockly.JavaScript['random_pick'] = function (block) { const array = Blockly.JavaScript.valueToCode(block, 'ARRAY', Blockly.JavaScript.ORDER_ATOMIC); return [`game.rnd.pick(${array})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns a random item from the list, favoring items at the beginning. * @method random_pick_weighted * @param array list to pick from * @returns {} * &lt;pre&gt;&lt;code&gt; * game.rnd.weightedPick(array) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Random * @block */ Blockly.JavaScript['random_pick_weighted'] = function (block) { const array = Blockly.JavaScript.valueToCode(block, 'ARRAY', Blockly.JavaScript.ORDER_ATOMIC); return [`game.rnd.weightedPick(${array})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns a random real number between 0 and 2^32. * @method random_real * @returns {} * &lt;pre&gt;&lt;code&gt; * game.rnd.real() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Random * @block */ Blockly.JavaScript['random_real'] = function (block) { return [`game.rnd.real()`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns a random number between the given range, inclusive. * @method random_real_in_range * @param min {Number} the minimum value in the range * @param max {Number} the maximum value in the range * @returns {} * &lt;pre&gt;&lt;code&gt; * game.rnd.realInRange(min, max) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Random * @block */ Blockly.JavaScript['random_real_in_range'] = function (block) { const min = Blockly.JavaScript.valueToCode(block, 'MIN', Blockly.JavaScript.ORDER_ATOMIC); const max = Blockly.JavaScript.valueToCode(block, 'MAX', Blockly.JavaScript.ORDER_ATOMIC); return [`game.rnd.realInRange(${min}, ${max})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Returns a random sign to be used with multiplication. Returns -1 or +1. * @method random_sign * @returns {} * &lt;pre&gt;&lt;code&gt; * game.rnd.sign() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Random * @block */ Blockly.JavaScript['random_sign'] = function (block) { return [`game.rnd.sign()`, Blockly.JavaScript.ORDER_NONE]; }; /** * Randomly returns true or false. * @method random_boolean * @returns {} * &lt;pre&gt;&lt;code&gt; * game.rnd.pick([true, false]) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Random * @block */ Blockly.JavaScript['random_boolean'] = function () { return ['game.rnd.pick([true, false])', Blockly.JavaScript.ORDER_NONE]; }; //endregion //region EASING /** * Returns the chosen easing method in the given direction. * @method phaser_easing * @param ease easing method to return * @param direction direction for the easing method to use * @returns {} * &lt;pre&gt;&lt;code&gt; * Phasser.ease.direction * &lt;/code&gt;&lt;/pre&gt; * @memberOf Math * @block */ Blockly.JavaScript['phaser_easing'] = function (block) { const ease = block.getFieldValue('EASING'); const direction = block.getFieldValue('DIRECTION'); return [`Phaser.${ease}.${direction}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns the linear easing method. * @method phaser_easing_linear * @returns {} * &lt;pre&gt;&lt;code&gt; * Phaser.Easing.Linear.None * &lt;/code&gt;&lt;/pre&gt; * @memberOf Math * @block */ Blockly.JavaScript['phaser_easing_linear'] = function (block) { return [`Phaser.Easing.Linear.None`, Blockly.JavaScript.ORDER_ATOMIC]; }; //endregion //region TWEEN /** * Creates and returns a tween with the given properties. It will start at the current value and tween to the destination value. * @method phaser_game_add_tween_to * @param target the object to add the tween to * @param duration {Number} duration of the tween * @param ease the easing function to use on the tween * @param autostart {Boolean} option to automatically start the tween instead of manually calling tween.start() * @param delay {Number} delay before the tween will start, in milliseconds * @param repeat {Number} how many times the tween should repeat. Set to -1 to run forever * @param yoyo {Boolean} option for the tween to reverse itself and play backwards * @param properties (optional) optional properties to add to the tween * @returns {} * &lt;pre&gt;&lt;code&gt; * game.add.tween(target).to(properties[if used], duration, ease, autostart, delay, repeat, yoyo) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Math * @block */ Blockly.JavaScript['phaser_game_add_tween_to'] = function (block) { const target = Blockly.JavaScript.valueToCode(block, 'TARGET', Blockly.JavaScript.ORDER_ATOMIC); const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC); const ease = Blockly.JavaScript.valueToCode(block, 'EASE', Blockly.JavaScript.ORDER_ATOMIC); const autostart = block.getFieldValue('AUTOSTART') === 'TRUE'; const delay = Blockly.JavaScript.valueToCode(block, 'DELAY', Blockly.JavaScript.ORDER_ATOMIC); const repeat = Blockly.JavaScript.valueToCode(block, 'REPEAT', Blockly.JavaScript.ORDER_ATOMIC); const yoyo = block.getFieldValue('YOYO') === 'TRUE'; let objectProperties = ''; for (let i = 0; i &lt; block.properties_.length; ++i) { objectProperties += `${block.properties_[i]}: ${Blockly.JavaScript.valueToCode(block, 'PROP' + i, Blockly.JavaScript.ORDER_COMMA)},`; } return [`game.add.tween(${target}).to({${objectProperties}}, ${duration}, ${ease}, ${autostart}, ${delay}, ${repeat}, ${yoyo})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Creates and returns a tween with the given properties. It will set the target to the destination value and tween to it's current value. * @method phaser_game_add_tween_from * @param target the object to add the tween to * @param duration {Number} duration of the tween * @param ease the easing function to use on the tween * @param autostart {Boolean} option to automatically start the tween instead of manually calling tween.start() * @param delay {Number} delay before the tween will start, in milliseconds * @param repeat {Number} how many times the tween should repeat. Set to -1 to run forever * @param yoyo {Boolean} option for the tween to reverse itself and play backwards * @param properties (optional) optional properties to add to the tween * @returns {} * &lt;pre&gt;&lt;code&gt; * game.add.tween(target).from(properties[if used], duration, ease, autostart, delay, repeat, yoyo) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Math * @block */ Blockly.JavaScript['phaser_game_add_tween_from'] = function (block) { const target = Blockly.JavaScript.valueToCode(block, 'TARGET', Blockly.JavaScript.ORDER_ATOMIC); const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC); const ease = Blockly.JavaScript.valueToCode(block, 'EASE', Blockly.JavaScript.ORDER_ATOMIC); const autostart = block.getFieldValue('AUTOSTART') === 'TRUE'; const delay = Blockly.JavaScript.valueToCode(block, 'DELAY', Blockly.JavaScript.ORDER_ATOMIC); const repeat = Blockly.JavaScript.valueToCode(block, 'REPEAT', Blockly.JavaScript.ORDER_ATOMIC); const yoyo = block.getFieldValue('YOYO') === 'TRUE'; let objectProperties = ''; for (let i = 0; i &lt; block.properties_.length; ++i) { objectProperties += `${block.properties_[i]}: ${Blockly.JavaScript.valueToCode(block, 'PROP' + i, Blockly.JavaScript.ORDER_COMMA)},`; } return [`game.add.tween(${target}).from({${objectProperties}}, ${duration}, ${ease}, ${autostart}, ${delay}, ${repeat}, ${yoyo})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Stop the chosen tween. * @method phaser_stop_tween * @param tween tween to stop * @param complete {Boolean} if true, dispatches the onComplete signal * @returns {} * &lt;pre&gt;&lt;code&gt; * tween.stop(complete); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Math * @block */ Blockly.JavaScript['phaser_stop_tween'] = function (block) { const tween = Blockly.JavaScript.valueToCode(block, 'TWEEN', Blockly.JavaScript.ORDER_ATOMIC); const complete = block.getFieldValue('COMPLETE') === 'TRUE'; return `${tween}.stop(${complete});\\n`; }; /** * Pauses the chosen tween. * @method phaser.pause.tween * @param tween tween to pause * @returns {} * &lt;pre&gt;&lt;code&gt; * tween.pause(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Math * @block */ Blockly.JavaScript['phaser_pause_tween'] = function (block) { const tween = Blockly.JavaScript.valueToCode(block, 'TWEEN', Blockly.JavaScript.ORDER_ATOMIC); return `${tween}.pause();\\n`; }; /** * Resumes the chosen tween. * @method phaser_resume_tween * @param tween tween to resume * @returns {} * &lt;pre&gt;&lt;code&gt; * tween.resume(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Math * @block */ Blockly.JavaScript['phaser_resume_tween'] = function (block) { const tween = Blockly.JavaScript.valueToCode(block, 'TWEEN', Blockly.JavaScript.ORDER_ATOMIC); return `${tween}.resume();\\n`; }; /** * Start the chosen tween object. * @method phaser_start_tween * @param tween tween to start * @returns {} * &lt;pre&gt;&lt;code&gt; * tween.start(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Math * @block */ Blockly.JavaScript['phaser_start_tween'] = function (block) { const tween = Blockly.JavaScript.valueToCode(block, 'TWEEN', Blockly.JavaScript.ORDER_ATOMIC); return `${tween}.start();\\n`; }; /** * Make the chosen tween run through the starting values and then play back in reverse. * @method phaser_yoyo_tween * @param tween tween to yoyo * @param enable {Boolean} enable/disable yoyoing on the tween * @param delay {Number} the amount of time to wait until the yoyo will start * @param index {Number} choose the object index on the tween to apply this to * @returns {} * &lt;pre&gt;&lt;code&gt; * tween.yoyo(enable, delay, index); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Math * @block */ Blockly.JavaScript['phaser_yoyo_tween'] = function (block) { const tween = Blockly.JavaScript.valueToCode(block, 'TWEEN', Blockly.JavaScript.ORDER_ATOMIC); const enable = block.getFieldValue('ENABLE') === 'TRUE'; const delay = Blockly.JavaScript.valueToCode(block, 'DELAY', Blockly.JavaScript.ORDER_ATOMIC); const index = Blockly.JavaScript.valueToCode(block, 'INDEX', Blockly.JavaScript.ORDER_ATOMIC); return `${tween}.yoyo(${enable}, ${delay}, ${index});\\n`; }; //endregion × Search results Close "},"phaser_input.js.html":{"id":"phaser_input.js.html","title":"Source: phaser_input.js","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Source: phaser_input.js /** * @namespace Keyboard */ //region KEYBOARD /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['create_cursor_keys'] = function (block) { return ['game.input.keyboard.createCursorKeys()', Blockly.JavaScript.ORDER_NONE]; }; /** * Returns true/false about whether or not the given key is currently being pressed down. * @method is_key_down * @param key key to check * @returns {} * &lt;pre&gt;&lt;code&gt; * game.input.keyboard.isDown(Phaser.Keyboard.key) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Keyboard * @block */ Blockly.JavaScript['is_key_down'] = function (block) { const key = block.getFieldValue('KEY'); return [`game.input.keyboard.isDown(Phaser.Keyboard.${key})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Creates a Phaser key object. * @method add_key * @param key keycode of the key to create * @returns {} * &lt;pre&gt;&lt;code&gt; * game.input.keyboard.addKey(Phaser.Keyboard.key) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Keyboard * @block */ Blockly.JavaScript['add_key'] = function (block) { const key = block.getFieldValue('KEYCODE'); return [`game.input.keyboard.addKey(Phaser.Keyboard.${key})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns the chosen boolean field value of the key. * @method get_key_boolean_field * @param field the value to get * @param key key to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * key.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Keyboard * @block */ /** * Returns the chosen numeric field value of the key. * @method get_key_numeric_field * @param field the value to get * @param key key to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * key.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Keyboard * @block */ Blockly.JavaScript['get_key_boolean_field'] = Blockly.JavaScript['get_key_numeric_field'] = function (block) { const field = block.getFieldValue('FIELD'); const key = Blockly.JavaScript.valueToCode(block, 'KEY', Blockly.JavaScript.ORDER_ATOMIC); return [`${key}.${field}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the given key was pressed down this update tick. * @method key_just_pressed * @param key key to check * @returns {} * &lt;pre&gt;&lt;code&gt; * key.justPressed() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Keyboard * @block */ Blockly.JavaScript['key_just_pressed'] = function (block) { const key = Blockly.JavaScript.valueToCode(block, 'KEY', Blockly.JavaScript.ORDER_ATOMIC); return [`${key}.justPressed()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the given key was released down this update tick. * @method key_just_released * @param key key to check * @returns {} * &lt;pre&gt;&lt;code&gt; * key.justReleased() * &lt;/code&gt;&lt;/pre&gt; * @memberOf Keyboard * @block */ Blockly.JavaScript['key_just_released'] = function (block) { const key = Blockly.JavaScript.valueToCode(block, 'KEY', Blockly.JavaScript.ORDER_ATOMIC); return [`${key}.justReleased()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Resets the state of the key. Hard reset removes any callback methods associated with it. * @method key_reset * @param key key to reset * @param hard {Boolean} whether or not to hard reset the key * @returns {} * &lt;pre&gt;&lt;code&gt; * key.reset(hard) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Keyboard * @block */ Blockly.JavaScript['key_reset'] = function (block) { const key = Blockly.JavaScript.valueToCode(block, 'KEY', Blockly.JavaScript.ORDER_ATOMIC); const hard = block.getFieldValue('HARD') == 'TRUE'; return `${key}.reset(${hard});\\n`; }; /** * Returns true/false if the given key was released within the given amount of time. * @method key_up_duration * @param key key to check * @param duration {Number} duration within which the key is considered as just released * @returns {} * &lt;pre&gt;&lt;code&gt; * key.upDuration(duration); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Keyboard * @block */ Blockly.JavaScript['key_up_duration'] = function (block) { const key = Blockly.JavaScript.valueToCode(block, 'KEY', Blockly.JavaScript.ORDER_ATOMIC); const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC); return [`${key}.upDuration(${duration})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the given key was pressed within the given amount of time. * @method key_up_duration * @param key key to check * @param duration {Number} duration within which the key is considered as just pressed * @returns {} * &lt;pre&gt;&lt;code&gt; * key.downDuration(duration); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Keyboard * @block */ Blockly.JavaScript['key_down_duration'] = function (block) { const key = Blockly.JavaScript.valueToCode(block, 'KEY', Blockly.JavaScript.ORDER_ATOMIC); const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC); return [`${key}.downDuration(${duration})`, Blockly.JavaScript.ORDER_ATOMIC]; }; //endregion /** * @namespace Mouse */ //region MOUSE /** * Returns the specified coordinate value of the mouse position. * @method get_current_mouse_position * @param direction which coordinate of the mouse position to get * @returns {} * &lt;pre&gt;&lt;code&gt; * game.input.direction * &lt;/code&gt;&lt;/pre&gt; * @memberOf Mouse * @block */ Blockly.JavaScript['get_current_mouse_position'] = function (block) { const direction = block.getFieldValue('DIRECTION'); return [`game.input.${direction}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns the mouse position as a point that contains the x/y values of the coordinates. * @method get_mouse_position_point * @returns {} * &lt;pre&gt;&lt;code&gt; * New Phaser.Point(game.input.x, game.input.y) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Mouse * @block */ Blockly.JavaScript['get_mouse_position_point'] = function (block) { return [`new Phaser.Point(game.input.x, game.input.y)`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the specified mouse button is currently being clicked. * @method is_mouse_button_clicked * @returns {} * &lt;pre&gt;&lt;code&gt; * game.input.mousePointer.button.isDown * &lt;/code&gt;&lt;/pre&gt; * @memberOf Mouse * @block */ Blockly.JavaScript['is_mouse_button_clicked'] = function (block) { return [`game.input.mousePointer.${block.getFieldValue('BUTTON')}.isDown`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns the active game pointer. * @method get_active_pointer * @returns {} * &lt;pre&gt;&lt;code&gt; * game.input.activePointer * &lt;/code&gt;&lt;/pre&gt; * @memberOf Mouse * @block */ Blockly.JavaScript['get_active_pointer'] = function (block) { return [`game.input.activePointer`, Blockly.JavaScript.ORDER_ATOMIC]; }; //endregion /** * @namespace InputHandler */ //region INPUT_HANDLER /** * Enables an object to use input handler methods and events. * @method input_handler_enable * @param object object to enable the input handler on * @returns {} * &lt;pre&gt;&lt;code&gt; * object.inputEnabled = true; * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_enable'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.inputEnabled = true;\\n`; }; /** * Assigns the chosen boolean field for the object. * @method set_input_handler_boolean_field * @param field the value to set * @param object object to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ /** * Assigns the chosen numeric field for the object. * @method set_input_handler_numeric_field * @param field the value to set * @param object object to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['set_input_handler_boolean_field'] = Blockly.JavaScript['set_input_handler_numeric_field'] = function (block) { const field = block.getFieldValue('FIELD'); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.${field} = ${value};\\n`; }; /** * Assigns the chosen point field for the object. * @method set_input_handler_point_field * @param field the value to set * @param object object to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.field.copyFrom(value); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['set_input_handler_point_field'] = function (block) { const field = block.getFieldValue('FIELD'); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.${field}.copyFrom(${value});\\n`; }; /** * Returns the chosen boolean field value of the object. * @method get_input_handler_boolean_field * @param field the value to get * @param object object to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ /** * Returns the chosen numeric field value of the object. * @method get_input_handler_numeric_field * @param field the value to get * @param object object to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ /** * Returns the chosen point field value of the object. * @method get_input_handler_point_field * @param field the value to get * @param object object to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['get_input_handler_boolean_field'] = Blockly.JavaScript['get_input_handler_numeric_field'] = Blockly.JavaScript['get_input_handler_point_field'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('FIELD'); return [`${object}.input.${field}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Sets the boundary of where the sprite is restricted while being dragged. * @method input_handler_bounds_rect_set * @param object object to set the boundary for * @param rect rectangle that defines the boundary * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.boundsRect = rect; * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_bounds_rect_set'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const rect = Blockly.JavaScript.valueToCode(block, 'RECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.boundsRect = ${rect};\\n`; }; /** * Allows the object to be clicked and dragged by the mouse. * @method input_handler_enable_drag * @param object object to enable dragging on * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.enableDrag(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_enable_drag'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.enableDrag();\\n`; }; /** * Allows the object to be clicked and dragged by the mouse, with customizable options. * @method input_handler_enable_drag_complex * @param object object to enable dragging on * @param center {Boolean} If false the Sprite will drag from where you click it minus the dragOffset. If true it will center itself to the tip of the mouse pointer * @param top {Boolean} If true the object will be displayed on top of everything else * @param pixel {Boolean} If true it will use a pixel perfect test to see if you clicked the object. False uses the bounding box * @param alpha {Boolean} If pixel perfect is true, this specifies the alpha level needed for collision to be processed * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.enableDrag(center, top, pixel, alpha); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_enable_drag_complex'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const center = block.getFieldValue('CENTER') === 'TRUE'; const top = block.getFieldValue('ALPHA') === 'TRUE'; const pixel = block.getFieldValue('PIXEL') === 'TRUE'; const alpha = Blockly.JavaScript.valueToCode(block, 'ALPHA', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.enableDrag(${center}, ${top}, ${pixel}, ${alpha});\\n`; }; /** * Returns true/false if the pointer is currently clicking on the object. * @method input_handler_check_pointer_down * @param pointer pointer to check * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * input.checkPointerDown(pointer) * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_check_pointer_down'] = function (block) { const pointer = Blockly.JavaScript.valueToCode(block, 'POINTER', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.checkPointerDown(${pointer})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the pointer is on top of the object. * @method input_handler_check_pointer_over * @param pointer pointer to check * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.checkPointerOver(pointer) * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_check_pointer_over'] = function (block) { const pointer = Blockly.JavaScript.valueToCode(block, 'POINTER', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.checkPointerOver(${pointer})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Stops the object from being dragged. If it is currently being dragged, it will be stopped immediately. * @method input_handler_disable_drag * @param object object to disable drag on * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.disableDrag(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_disable_drag'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.disableDrag();\\n`; }; /** * Make the object snap to the given x/y grid when being dragged or released. * @method input_handler_enable_snap * @param object object to snap * @param x {Number} the width of the grid to snap to * @param y {Number} the height of the grid to snap to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.enableSnap(x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_enable_snap'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.enableSnap(${x}, ${y});\\n`; }; /** * Make the object snap to the given x/y grid when being dragged or released, with customizable options. * @method input_handler_enable_snap_complex * @param object object to snap * @param x {Number} the width of the grid to snap to * @param y {Number} the height of the grid to snap to * @param drag {Boolean} makes the object snap to the grid while being dragged * @param release {Boolean} makes the object snap to the grid when released * @param offset_x {Number} offsets the top left starting point of the grid * @param offset_y {Number} offsets the top left starting point of the grid * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.enableSnap(x, y, drag, release, offset_x, offset_y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_enable_snap_complex'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const drag = block.getFieldValue('DRAG') === 'TRUE'; const release = block.getFieldValue('RELEASE') === 'TRUE'; const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const offset_x = Blockly.JavaScript.valueToCode(block, 'OFFSET_X', Blockly.JavaScript.ORDER_ATOMIC); const offset_y = Blockly.JavaScript.valueToCode(block, 'OFFSET_Y', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.enableSnap(${x}, ${y}, ${drag}, ${release}, ${offset_x}, ${offset_y});\\n`; }; /** * Stops the object from snapping to a grid while being dragged and released. * @method input_handler_disable_snap * @param object object to disable snap for * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.disableSnap(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_disable_snap'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.disableSnap();\\n`; }; /** * Returns true/false if the alpha value at the given location is greater than or equal to the object's pixelPerfectAlpha value. * @method input_handler_check_pixel * @param x {Number} x coordinate to check * @param y {Number} y coordinate to check * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.checkPixel(x, y) * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_check_pixel'] = function (block) { const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.checkPixel(${x}, ${y})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the object is using pixel perfect checking. * @method input_handler_is_pixel_perfect * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.isPixelPerfect() * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_is_pixel_perfect'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.isPixelPerfect()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the object was clicked on within the given time. * @method input_handler_just_pressed * @param object object to check * @param time {Number} the duration to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.justPressed(0, time) * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_just_pressed'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const time = Blockly.JavaScript.valueToCode(block, 'TIME', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.justPressed(0, ${time})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the object was released on within the given time. * @method input_handler_just_released * @param object object to check * @param time {Number} the duration to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.justReleased(0, time) * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_just_released'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const time = Blockly.JavaScript.valueToCode(block, 'TIME', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.justReleased(0, ${time})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns the number of milliseconds the mouse has been hovering over the object. * @method input_handler_over_duration * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.overDuration() * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_over_duration'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.overDuration()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['input_handler_pointer_over'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.pointerOver()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the mouse has entered the object's bounds within the given time. * @method input_handler_just_over * @param object object to check * @param time {Number} time to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.justOver(0, time) * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_just_over'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const time = Blockly.JavaScript.valueToCode(block, 'TIME', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.justOver(0, ${time})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns the number of milliseconds the mouse has been clicking on the object. * @method input_handler_down_duration * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.downDuration() * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_down_duration'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.downDuration()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the pointer is up. * @method input_handler_pointer_up * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.pointerUp() * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_pointer_up'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.pointerUp()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the pointer is down. * @method input_handler_pointer_down * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.pointerDown() * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_pointer_down'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.pointerDown()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Starts the Input Handler. This is automatically called if input is enabled on an object. Higher priority objects take click priority when objects are stacked on top of each other. * @method input_handler_start * @param object object to start input handler for * @param priority {Number} the priority of the object * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.start(priority); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_start'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const priority = Blockly.JavaScript.valueToCode(block, 'PRIORITY', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.start(${priority});\\n`; }; /** * Stops the Input Handler from running on the object. * @method input_handler_stop * @param object object to affect * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.stop(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_stop'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.stop();\\n`; }; /** * Returns true/false if the pointer left the object's bounds within the given duration. * @method input_handler_just_out * @param object object to check * @param time {Number} duration to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.justOut(0, time) * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_just_out'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const time = Blockly.JavaScript.valueToCode(block, 'TIME', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.justOut(0, ${time})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns true/false if the pointer is outside of the object's bounds. * @method input_handler_pointer_out * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.pointerOut() * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_pointer_out'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.pointerOut()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns the x coordinate of the pointer, relative to the top-left of anchor of the object. * @method input_handler_pointer_x * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.pointerX() * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_pointer_x'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.pointerX()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns the y coordinate of the pointer, relative to the top-left of anchor of the object. * @method input_handler_pointer_y * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.pointerY() * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_pointer_y'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.pointerY()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns a point containing the x &amp; y coordinates of the pointer, relative to the top-left of the anchor of the object. * @method input_handler_pointer_position * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * new Phaser.Point(object.input.pointerX(), object.input.pointerY()) * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_pointer_position'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const position = `new Phaser.Point(${object}.input.pointerX(), ${object}.input.pointerY())`; return [`${position}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Resets the input handler for the object, and disables it. * @method input_handler_reset * @param object object to reset the input handler for * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.reset(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_reset'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.reset();\\n`; }; /** * Destroys the input handler for the object. * @method input_handler_destroy * @param object object to destroy the handler for * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.destroy(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_destroy'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.input.destroy();\\n`; }; /** * Returns true/false if the object is currently being dragged. * @method input_handler_pointer_dragged * @param object object to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.pointerDragged() * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_pointer_dragged'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.input.pointerDragged()`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Locks dragging for the object in certain directions. * @method input_handler_set_drag_lock * @param object object to lock dragging for * @param horizontal {Boolean} enables/disables the object from being dragged horizontally * @param vertical {Boolean} enables/disables the object from being dragged vertically * @returns {} * &lt;pre&gt;&lt;code&gt; * object.input.setDragLock(horizontal, vertical); * &lt;/code&gt;&lt;/pre&gt; * @memberOf InputHandler * @block */ Blockly.JavaScript['input_handler_set_drag_lock'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const horizontal = block.getFieldValue('HORIZONTAL') === 'TRUE'; const vertical = block.getFieldValue('VERTICAL') === 'TRUE'; return `${object}.input.setDragLock(${horizontal}, ${vertical});\\n`; }; //endregion /** * @namespace Pointer */ //region POINTER /** * Returns the chosen button from the mouse. * @method pointer_get_device_buttons_field * @param object pointer to get the buttons from * @param field which button to return * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Pointer * @block */ Blockly.JavaScript['pointer_get_device_buttons_field'] = getField; //endregion /** * @namespace DeviceButton */ //region DEVICE_BUTTON /** * Returns the chosen boolean field value of the chosen button on the pointer. * @method device_button_get_boolean_field * @param object button to get the values from * @param field the value to get * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf DeviceButton * @block */ /** * Returns the chosen numeric field value of the chosen button on the pointer. * @method device_button_get_numeric_field * @param object button to get the values from * @param field the value to get * @returns {} * &lt;pre&gt;&lt;code&gt; * object.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf DeviceButton * @block */ Blockly.JavaScript['device_button_get_boolean_field'] = Blockly.JavaScript['device_button_get_numeric_field'] = getField; /** * Returns true/false if the chosen button on the pointer was released within the last 250 milliseconds. * @method device_button_just_released * @param object button to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.justReleased() * &lt;/code&gt;&lt;/pre&gt; * @memberOf DeviceButton * @block */ Blockly.JavaScript['device_button_just_released'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.justReleased()`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns true/false if the chosen button on the pointer was pressed within the last 250 milliseconds. * @method device_button_just_pressed * @param object button to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.justPressed() * &lt;/code&gt;&lt;/pre&gt; * @memberOf DeviceButton * @block */ Blockly.JavaScript['device_button_just_pressed'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.justPressed()`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns true/false if the chosen button on the pointer was released within the given amount of time. * @method device_button_just_released_complex * @param object button to check * @param duration {Number} the duration to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.justReleased(duration) * &lt;/code&gt;&lt;/pre&gt; * @memberOf DeviceButton * @block */ Blockly.JavaScript['device_button_just_released_complex'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.justReleased(${duration})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * Returns true/false if the chosen button on the pointer was pressed within the given amount of time. * @method device_button_just_pressed_complex * @param object button to check * @param duration {Number} the duration to check * @returns {} * &lt;pre&gt;&lt;code&gt; * object.justPressed(duration) * &lt;/code&gt;&lt;/pre&gt; * @memberOf DeviceButton * @block */ Blockly.JavaScript['device_button_just_pressed_complex'] = function (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.justPressed(${duration})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; //endregion × Search results Close "},"phaser_graphics.js.html":{"id":"phaser_graphics.js.html","title":"Source: phaser_graphics.js","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Source: phaser_graphics.js /** * @namespace Graphics */ //region DRAWPRIMITIVES /** * Adds a graphics object to use to draw primitive shapes. * @method create_graphics_object * @param x {Number} x position of the new graphics object * @param y {Number} y position of the new graphics object * @returns {} * &lt;pre&gt;&lt;code&gt; * game.add.graphics(x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Graphics * @block */ Blockly.JavaScript['create_graphics_object'] = function (block) { const value_x = Blockly.JavaScript.valueToCode(block, 'x', Blockly.JavaScript.ORDER_ATOMIC); const value_y = Blockly.JavaScript.valueToCode(block, 'y', Blockly.JavaScript.ORDER_ATOMIC); // TODO: Change ORDER_NONE to the correct strength. return [`game.add.graphics(${value_x}, ${value_y})`, Blockly.JavaScript.ORDER_NONE]; }; /** * Enables graphics filling for shapes. * @method draw_shapes_with_colour * @param colour the colour to fill the shapes with * @param graphics the graphics object to use * @returns {} * &lt;pre&gt;&lt;code&gt; * graphics.beginFill(toHexColor(colour)); * (shapes to fill) * graphics.endFill(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Graphics * @block */ Blockly.JavaScript['draw_shapes_with_colour'] = function (block) { let value_colour = Blockly.JavaScript.valueToCode(block, 'colour', Blockly.JavaScript.ORDER_ATOMIC); const variable_graphics_object_name = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('graphics_object_name'), Blockly.Variables.NAME_TYPE); const statements_shape_draw_functions = Blockly.JavaScript.statementToCode(block, 'shape draw functions'); const toHexColorFunc = Blockly.JavaScript.provideFunction_( 'toHexColor', ['function ' + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + '(color) {', 'return color.replace(&quot;#&quot;, &quot;0x&quot;);', '}']); return `${variable_graphics_object_name}.beginFill(${toHexColorFunc}(${value_colour}));\\n ${statements_shape_draw_functions}\\n ${variable_graphics_object_name}.endFill();\\n`; }; /** * Draws a rectangle. Use inside of {@link draw_shapes_with_colour} * @method draw_rectangle * @param x {Number} x position of the rectangle * @param y {Number} y position of the rectangle * @param width {Number} the width of the rectangle * @param height {Number} the height of the rectangle * @returns {} * &lt;pre&gt;&lt;code&gt; * graphicsVar.drawRect(x, y, width, height); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Graphics * @block */ Blockly.JavaScript['draw_rectangle'] = function (block) { const value_x = Blockly.JavaScript.valueToCode(block, 'x', Blockly.JavaScript.ORDER_ATOMIC); const value_y = Blockly.JavaScript.valueToCode(block, 'y', Blockly.JavaScript.ORDER_ATOMIC); const value_w = Blockly.JavaScript.valueToCode(block, 'w', Blockly.JavaScript.ORDER_ATOMIC); const value_h = Blockly.JavaScript.valueToCode(block, 'h', Blockly.JavaScript.ORDER_ATOMIC); const variable_graphics_object_name = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('graphics_object_name'), Blockly.Variables.NAME_TYPE); return `${variable_graphics_object_name}.drawRect(${value_x}, ${value_y}, ${value_w}, ${value_h});\\n`; }; /** * Draws a circle. Use inside of {@link draw_shapes_with_colour} * @method draw_circle * @param x {Number} x position of the rectangle * @param y {Number} y position of the rectangle * @param diameter {Number} the diameter of the rectangle * @returns {} * &lt;pre&gt;&lt;code&gt; * graphicsVar.drawCircle(x, y, diameter); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Graphics * @block */ Blockly.JavaScript['draw_circle'] = function (block) { const value_x = Blockly.JavaScript.valueToCode(block, 'x', Blockly.JavaScript.ORDER_ATOMIC); const value_y = Blockly.JavaScript.valueToCode(block, 'y', Blockly.JavaScript.ORDER_ATOMIC); const value_diameter = Blockly.JavaScript.valueToCode(block, 'DIAMETER', Blockly.JavaScript.ORDER_ATOMIC); const variable_graphics_object_name = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('graphics_object_name'), Blockly.Variables.NAME_TYPE); return `${variable_graphics_object_name}.drawCircle(${value_x}, ${value_y}, ${value_diameter});\\n`; }; //endregion //region DRAW CIRCLE /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['drawcircle'] = function (block) { const value_x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC); const value_y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC); const value_diameter = Blockly.JavaScript.valueToCode(block, 'DIAMETER', Blockly.JavaScript.ORDER_ATOMIC); // TODO: Assemble JavaScript into code variable. var code = '...;\\n'; return code; }; //endregion × Search results Close "},"phaser.js.html":{"id":"phaser.js.html","title":"Source: phaser.js","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Source: phaser.js /** * @author Luke Powell * @author Aeon Williams * @file Generates JavaScript for phaser blocks * @copyright DigiPen Institute of Technology 2016 * &lt;/code&gt;&lt;/pre&gt; * @block */ //region MEMBER_FUNCTIONS /** * Generic method to translate a block for a set_&lt;object&gt;_&lt;type&gt;_member block * @param block A block containing two value inputs OBJECT and VALUE representing the object the member is on and the value to set it to and a field ELEMENT to determine the member * &lt;/code&gt;&lt;/pre&gt; * @block * @ignore */ function getMember (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const element = block.getFieldValue('ELEMENT'); return [`${object}.${element}`, Blockly.JavaScript.ORDER_ATOMIC]; } function getField (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('FIELD'); return [`${object}.${field}`, Blockly.JavaScript.ORDER_ATOMIC]; } /** * Generic method to translate a block for a get_&lt;object&gt;_&lt;type&gt;_member block * @param block A block containing a value input OBJECT representing the object the member is on and a field ELEMENT to determine the member * @return {String} * &lt;/code&gt;&lt;/pre&gt; * @block * @ignore */ function setMember (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const element = block.getFieldValue('ELEMENT'); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.${element} = ${value};\\n`; } function setPointField (block) { const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const field = block.getFieldValue('PROPERTY'); const point = Blockly.JavaScript.valueToCode(block, 'POINT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.${field}.copyFrom(${point});\\n`; } //endregion //region GET_OBJECT_WIDTH //TODO: TO COMPLETE /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['get_object_width'] = function (block) { const variable_name = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('NAME'), Blockly.Variables.NAME_TYPE); return [`${variable_name}.width`, Blockly.JavaScript.ORDER_NONE]; }; //endregion //region SET_OBJECT_WIDTH /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_object_width'] = function (block) { const variable_name = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('NAME'), Blockly.Variables.NAME_TYPE); const value_name = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_ATOMIC); return [`${variable_name} = ${value_name}`, Blockly.JavaScript.ORDER_NONE]; }; //endregion //region HELPER_FUNCTIONS function timerComplexHelper (block) { let code = ''; for (let i = 0; i &lt; block.itemCount_; i++) { code += Blockly.JavaScript.valueToCode(block, 'ADD' + i, Blockly.JavaScript.ORDER_ATOMIC) || ''; if (i &lt; block.itemCount_ - 1) { code += ' , '; } } return code; } × Search results Close "},"phaser_sound.js.html":{"id":"phaser_sound.js.html","title":"Source: phaser_sound.js","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Source: phaser_sound.js /** * @namespace Sound */ //region SOUND /** * Creates a sound with the given tag by loading it into the audio queue. * @method load_sound * @param tag {String} tag to name the sound * @param source {String} file path of the sound * @returns {} * &lt;pre&gt;&lt;code&gt; * game.load.audio(tag, source); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['load_sound'] = function (block) { const tag = Blockly.JavaScript.valueToCode(block, 'TAG', Blockly.JavaScript.ORDER_ATOMIC); const source = Blockly.JavaScript.valueToCode(block, 'SOURCE', Blockly.JavaScript.ORDER_ATOMIC); return `game.load.audio(${tag}, ${source});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['play_sound'] = function (block) { const tag = Blockly.JavaScript.valueToCode(block, 'TAG', Blockly.JavaScript.ORDER_ATOMIC); const volume = Blockly.JavaScript.valueToCode(block, 'VOLUME', Blockly.JavaScript.ORDER_ATOMIC); const looping = block.getFieldValue('LOOPING') == 'TRUE'; return `game.sound.play(${tag}, ${volume}, ${looping});\\n`; }; /** * Returns a new sound object. * @method add_sound * @param tag {String} the tag of the sound to add * @param volume {Number} volume to play the sound at * @param looping {Boolean} whether or not to loop the sound when it's played * @returns {} * &lt;pre&gt;&lt;code&gt; * game.add.audio(tag, volume, looping) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['add_sound'] = function (block) { const tag = Blockly.JavaScript.valueToCode(block, 'TAG', Blockly.JavaScript.ORDER_ATOMIC); const volume = Blockly.JavaScript.valueToCode(block, 'VOLUME', Blockly.JavaScript.ORDER_ATOMIC); const looping = block.getFieldValue('LOOPING') == 'TRUE'; return [`game.add.audio(${tag}, ${volume}, ${looping})`, Blockly.JavaScript.ORDER_FUNCTION_CALL]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['remove_sound'] = function (block) { const tag = Blockly.JavaScript.valueToCode(block, 'TAG', Blockly.JavaScript.ORDER_ATOMIC); return `game.sound.removeByKey(${tag});\\n`; }; /** * Stop, pause, or remove all sounds in the game. * @method stop_pause_resume_sounds * @param option which option to do * @returns {} * &lt;pre&gt;&lt;code&gt; * game.sound.optionAll(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['stop_pause_resume_sounds'] = function (block) { const option = block.getFieldValue('OPTION'); return `game.sound.${option}All();\\n`; }; /** * Assigns the chosen boolean field for the sound. * @method set_sound_boolean_member * @param element the field to set * @param object sound to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.element = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ /** * Assigns the chosen numeric field for the sound. * @method set_sound_numeric_member * @param element the field to set * @param object sound to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * object.element = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['set_sound_boolean_member'] = Blockly.JavaScript['set_sound_numeric_member'] = setMember; /** * Returns the chosen boolean field value of the sound. * @method get_sound_boolean_member * @param object object to get values from * @param element the element to get values of * @returns {} * &lt;pre&gt;&lt;code&gt; * object.element * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ /** * Returns the chosen numeric field value of the sound. * @method get_sound_numeric_member * @param object object to get values from * @param element the element to get values of * @returns {} * &lt;pre&gt;&lt;code&gt; * object.element * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ /** * Returns the chosen string field value of the sound. * @method get_sound_string_member * @param object object to get values from * @param element the element to get values of * @returns {} * &lt;pre&gt;&lt;code&gt; * object.element * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['get_sound_boolean_member'] = Blockly.JavaScript['get_sound_numeric_member'] = Blockly.JavaScript['get_sound_string_member'] = getMember; /** * Starts playing the sound at a volume of 0, and reaches the maximum volume for the sound over the given time, with the option to loop. * @method sound_fade_in * @param sound_object sound to play * @param duration {Number} the time it takes for the sound to reach maximum volume * @param loop {Boolean} whether or not the sound should loop * @returns {} * &lt;pre&gt;&lt;code&gt; * sound_object.fadeIn(duration, loop); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['sound_fade_in'] = function (block) { const sound_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const loop = block.getFieldValue('LOOP') == 'TRUE'; return `${sound_object}.fadeIn(${duration}, ${loop});\\n`; }; /** * Makes the sound go from it's current volume to a volume of 0 over the given time. * @method sound_fade_out * @param sound_object sound to stop * @param duration {Number} the time it takes for the sound to reach 0 * @returns {} * &lt;pre&gt;&lt;code&gt; * sound_object.fadeOut(duration); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['sound_fade_out'] = function (block) { const sound_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC) || '0'; return `${sound_object}.fadeOut(${duration});\\n`; }; /** * Makes the sound go from it's current volume to the given volume over the given time. * @method sound_fade_to * @param sound_object sound to change * @param duration {Number} the time it takes for the sound to reach the new volume * @param volume {Number} the volume to change the sound to * @returns {} * &lt;pre&gt;&lt;code&gt; * sound_object.fadeTo(duration, volume); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['sound_fade_to'] = function (block) { const sound_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const volume = Blockly.JavaScript.valueToCode(block, 'VOLUME', Blockly.JavaScript.ORDER_ATOMIC); return `${sound_object}.fadeTo(${duration}, ${volume});\\n`; }; /** * Loops the entire sound at the given volume. * @method sound_loop_full * @param sound_object sound to loop * @param volume {Number} volume to play the sound at * @returns {} * &lt;pre&gt;&lt;code&gt; * sound_object.loopFull(volume); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['sound_loop_full'] = function (block) { const sound_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const volume = Blockly.JavaScript.valueToCode(block, 'VOLUME', Blockly.JavaScript.ORDER_ATOMIC); return `${sound_object}.loopFull(${volume});\\n`; }; /** * Stop the sound playing. * @method sound_stop * @param sound_object sound to stop * @returns {} * &lt;pre&gt;&lt;code&gt; * sound_object.stop(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['sound_stop'] = function (block) { const sound_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; return `${sound_object}.stop();\\n`; }; /** * Pause the sound. * @method sound_pause * @param sound_object sound to pause * @returns {} * &lt;pre&gt;&lt;code&gt; * sound_object.pause(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['sound_pause'] = function (block) { const sound_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; return `${sound_object}.pause();\\n`; }; /** * Resume the sound. * @method sound_resume * @param sound_object sound to resume * @returns {} * &lt;pre&gt;&lt;code&gt; * sound_object.resume(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['sound_resume'] = function (block) { const sound_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; return `${sound_object}.resume();\\n`; }; /** * Play the sound with the given properties. * @method sound_play * @param sound_object sound to play * @param position {Number} position to play the sound from * @param volume {Number} volume to play the sound at * @param loop {Boolean} whether or not the sound should loop * @param restart {Boolean} option to force the sound to restart from the beginning * @returns {} * &lt;pre&gt;&lt;code&gt; * sound_object.play('', position, volume, loop, restart); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['sound_play'] = function (block) { const sound_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const position = Blockly.JavaScript.valueToCode(block, 'POSITION', Blockly.JavaScript.ORDER_ATOMIC); const volume = Blockly.JavaScript.valueToCode(block, 'VOLUME', Blockly.JavaScript.ORDER_ATOMIC); const loop = block.getFieldValue('LOOP') == 'TRUE'; const restart = block.getFieldValue('RESTART') == 'TRUE'; return `${sound_object}.play('', ${position}, ${volume}, ${loop}, ${restart});\\n`; }; /** * Restarts the sound with the given properties. * @method sound_restart * @param sound_object sound to restart * @param position {Number} the starting position to play the sound from * @param volume {Number} the volume to play the sound at * @param loop {Boolean} whether or not the sound should loop * @returns {} * &lt;pre&gt;&lt;code&gt; * sound_object.play('', position, volume loop); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Sound * @block */ Blockly.JavaScript['sound_restart'] = function (block) { const sound_object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC) || 'null'; const position = Blockly.JavaScript.valueToCode(block, 'POSITION', Blockly.JavaScript.ORDER_ATOMIC); const volume = Blockly.JavaScript.valueToCode(block, 'VOLUME', Blockly.JavaScript.ORDER_ATOMIC); const loop = block.getFieldValue('LOOP') == 'TRUE'; return `${sound_object}.play('', ${position}, ${volume}, ${loop});\\n`; }; //endregion × Search results Close "},"phaser_game.js.html":{"id":"phaser_game.js.html","title":"Source: phaser_game.js","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Source: phaser_game.js /** * @namespace Startup */ //region STARTUP /** * &lt;img src=&quot;img/phaser_simple_init.jpg&quot; width=&quot;250&quot;&gt; &lt;br&gt; * The main controller for the entire Phaser game. The functions run in order from top to bottom, with preload and create running once, and update running as a loop until the game ends. * [Check the game engine documentation for more details.]{@link http://dragondrop.digipen.edu/docs/Phaser.Timer.html} * @param width {Number} The width of the game world * @param height {Number} The height of the game world * @returns {} * &lt;pre&gt;&lt;code&gt; * var game = new Phaser.Game([width], [height], Phaser.AUTO, '', {preload: preload, create: create, update: update}); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Startup * @block */ Blockly.JavaScript['phaser_simple_init'] = function (block) { Blockly.JavaScript.addReservedWords('game, preload, create, update'); const number_width = block.getFieldValue('WIDTH'); const number_height = block.getFieldValue('HEIGHT'); const statements_preload = Blockly.JavaScript.statementToCode(block, 'PRELOAD'); const statements_create = Blockly.JavaScript.statementToCode(block, 'CREATE'); const statements_update = Blockly.JavaScript.statementToCode(block, 'UPDATE'); const phaser = `var game = new Phaser.Game(${number_width}, ${number_height}, Phaser.AUTO, '', {preload: preload, create: create, update: update});\\n\\n`; const preload = `function preload() {\\n${statements_preload}\\n}\\n\\n`; const create = `function create() {\\n game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\\n this.scale.pageAlignHorizontally = true;\\n this.scale.pageAlignVertically = true;\\n this.scale.updateLayout( true );\\n${statements_create}\\n}\\n\\n`; const update = `function update() {\\n${statements_update}\\n}\\n\\n`; return phaser + preload + create + update; }; /**The main controller for the entire Phaser game. Starts an instance of phaser without using preload, create, and update. * @method start_phaser_for_states * @param width {Number} The width of the game world * @param height {Number} The height of the game world * @returns {} * &lt;pre&gt;&lt;code&gt; * var game = new Phaser.Game(${number_width}, ${number_height}, Phaser.AUTO, ''); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Startup * @block */ Blockly.JavaScript['start_phaser_for_states'] = function (block) { const number_width = block.getFieldValue('WIDTH'); const number_height = block.getFieldValue('HEIGHT'); return `var game = new Phaser.Game(${number_width}, ${number_height}, Phaser.AUTO, '');\\n`; }; /** * Stretch the stuff * @method center_and_stretch * @returns {} * &lt;pre&gt;&lt;code&gt; * game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL; this.scale.pageAlignHorizontally = true; this.scale.pageAlignVertically = true; this.scale.updateLayout( true ); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Startup * @block */ Blockly.JavaScript['center_and_stretch'] = function (block) { return 'game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\\n this.scale.pageAlignHorizontally = true;\\n this.scale.pageAlignVertically = true;\\n this.scale.updateLayout( true );\\n'; }; //endregion /** * @namespace World */ //region WORLD /** * Returns the property of the object. * @method get_world_property * @param property property to get values from * @returns {} * &lt;pre&gt;&lt;code&gt; * game.world.property * &lt;/code&gt;&lt;/pre&gt; * @memberOf World * @block */ Blockly.JavaScript['get_world_property'] = function (block) { const property = block.getFieldValue('NAME'); return [`game.world.${property}`, Blockly.JavaScript.ORDER_NONE]; }; /** * Sets the top-left coordinates and size/physical bounds of the game world. * @method set_world_bounds * @param x {Number} the x coordinate of the top-left corner of the world * @param y {Number} the y coordinate of the top-left corner of the world * @param w {Number} the width of the game world * @param h {Number} the height of the game world * @returns {} * &lt;pre&gt;&lt;code&gt; * game.world.setBounds(x, y, w, h); * &lt;/code&gt;&lt;/pre&gt; * @memberOf World * @block */ Blockly.JavaScript['set_world_bounds'] = function (block) { const x = Blockly.JavaScript.valueToCode(block, 'X_POS', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'Y_POS', Blockly.JavaScript.ORDER_ATOMIC); const w = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_ATOMIC); const h = Blockly.JavaScript.valueToCode(block, 'HEIGHT', Blockly.JavaScript.ORDER_ATOMIC); return `game.world.setBounds(${x}, ${y}, ${w}, ${h});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['create_point'] = function (block) { const value_x = Blockly.JavaScript.valueToCode(block, 'X_POS', Blockly.JavaScript.ORDER_ATOMIC); const value_y = Blockly.JavaScript.valueToCode(block, 'Y_POS', Blockly.JavaScript.ORDER_ATOMIC); return [`new Phaser.Point(${value_x}, ${value_y})`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_scale'] = function (block) { const xScale = Blockly.JavaScript.valueToCode(block, 'SCALE_X', Blockly.JavaScript.ORDER_ATOMIC); const yScale = Blockly.JavaScript.valueToCode(block, 'SCALE_Y', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.variableDB_.getName(block.getFieldValue('OBJECT'), Blockly.Variables.NAME_TYPE); return `${object}.scale.setTo(${xScale}, ${yScale});\\n`; }; /** * Sets the scale of the object. * @method set_scale_vi * @param x {Number} amount to scale the object in the x direction * @param y {Number} amount to scale the object in the y direction * @param object object to scale * @returns {} * &lt;pre&gt;&lt;code&gt; * object.scale.setTo(x, y); * &lt;/code&gt;&lt;/pre&gt; * @memberOf World * @block */ Blockly.JavaScript['set_scale_vi'] = function (block) { const x = Blockly.JavaScript.valueToCode(block, 'SCALE_X', Blockly.JavaScript.ORDER_ATOMIC); const y = Blockly.JavaScript.valueToCode(block, 'SCALE_Y', Blockly.JavaScript.ORDER_ATOMIC); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.scale.setTo(${x}, ${y});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_pos'] = function (block) { const param_name = block.getFieldValue('PARAM'); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const val = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.${param_name} = ${val};\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['set_velocity'] = function (block) { const param_name = block.getFieldValue('PARAM'); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); const val = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${object}.${param_name} = ${val};\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['get_param'] = function (block) { const param_name = block.getFieldValue('PARAM'); const object = Blockly.JavaScript.valueToCode(block, 'OBJECT', Blockly.JavaScript.ORDER_ATOMIC); return [`${object}.${param_name}`, Blockly.JavaScript.ORDER_NONE]; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['get_world_reference'] = function (block) { return [`game.world`, Blockly.JavaScript.ORDER_NONE]; }; /** * Pauses/unpauses the game. * @method set_game_pause * @param paused {Boolean} sets the game paused to true or false * @returns {} * &lt;pre&gt;&lt;code&gt; * game.paused = paused; * &lt;/code&gt;&lt;/pre&gt; * @memberOf World * @block */ Blockly.JavaScript['set_game_pause'] = function (block) { var paused = Blockly.JavaScript.valueToCode(block, 'PAUSED', Blockly.JavaScript.ORDER_ATOMIC); return `game.paused = ${paused};\\n`; }; /** * Returns whether or not the game is paused. * @method get_game_pause * @returns {} * &lt;pre&gt;&lt;code&gt; * game.paused * &lt;/code&gt;&lt;/pre&gt; * @memberOf World * @block */ Blockly.JavaScript['get_game_pause'] = function (block) { return [`game.paused`, Blockly.JavaScript.ORDER_ATOMIC]; }; //endregion /** * @namespace States */ //region STATES /** * Adds a state to the game with the given name and key. * @method statemanager_add_state * @param name {String} name of the new state * @param key tag to use for the state * @returns {} * &lt;pre&gt;&lt;code&gt; * game.state.add(key, name); * &lt;/code&gt;&lt;/pre&gt; * @memberOf States * @block */ Blockly.JavaScript['statemanager_add_state'] = function (block) { const name = Blockly.JavaScript.valueToCode(block, 'NAME', Blockly.JavaScript.ORDER_ATOMIC); const key = block.getFieldValue('KEY'); return `game.state.add('${key}', ${name});\\n`; }; /** * Start the state with the given tag. * @method statemanager_start_state * @param tag tag of the state to start * @returns {} * &lt;pre&gt;&lt;code&gt; * game.start.state(tag); * &lt;/code&gt;&lt;/pre&gt; * @memberOf States * @block */ Blockly.JavaScript['statemanager_start_state'] = function (block) { const tag = block.getFieldValue('TAG'); return `game.state.start('${tag}');\\n`; }; /** * Returns the state that is currently running. * @method statemanager_get_current_state * @returns {} * &lt;pre&gt;&lt;code&gt; * game.state.getCurrentState() * &lt;/code&gt;&lt;/pre&gt; * @memberOf States * @block */ Blockly.JavaScript['statemanager_get_current_state'] = function (block) { return [`game.state.getCurrentState()`, Blockly.JavaScript.ORDER_NONE]; }; /** * Restarts the current state. * @method statemanager_restart_state * @returns {} * &lt;pre&gt;&lt;code&gt; * game.state.restart(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf States * @block */ Blockly.JavaScript['statemanager_restart_state'] = function (block) { return `game.state.restart();\\n`; }; /** * Returns true or false if the state with the given tag is valid. * @method statemanager_check_state * @param key {String} tag of the state to check * @returns {} * &lt;pre&gt;&lt;code&gt; * game.state.checkState(key) * &lt;/code&gt;&lt;/pre&gt; * @memberOf States * @block */ Blockly.JavaScript['statemanager_check_state'] = function (block) { const key = Blockly.JavaScript.valueToCode(block, 'KEY', Blockly.JavaScript.ORDER_ATOMIC); return [`game.state.checkState(${key})`, Blockly.JavaScript.ORDER_NONE]; }; //endregion /** * @namespace Time */ //region TIME /** * Returns the chosen numeric field value of the game timer. * @method get_time_numeric_member * @param field the value to get * @returns {} * &lt;pre&gt;&lt;code&gt; * game.time.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['get_time_numeric_member'] = function (block) { const field = block.getFieldValue('PROPERTY'); return [`game.time.${field}`, Blockly.JavaScript.ORDER_NONE]; }; /** * Assigns the chosen numeric field for the game timer. * @method set_time_numeric_member * @param field the value to set * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * game.time.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['set_time_numeric_member'] = function (block) { const field = block.getFieldValue('PROPERTY'); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `game.time.${field} = ${value};\\n`; }; /** * Returns the physics update delta in seconds. * @method delta_time_seconds * @returns {} * &lt;pre&gt;&lt;code&gt; * game.time.physicsElapsed * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['delta_time_seconds'] = function (block) { return [`game.time.physicsElapsed`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns the physics update delta in milliseconds. * @method delta_time_milliseconds * @returns {} * &lt;pre&gt;&lt;code&gt; * game.time.physicsElapsedMS * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['delta_time_milliseconds'] = function (block) { return [`game.time.physicsElapsedMS`, Blockly.JavaScript.ORDER_ATOMIC]; }; //endregion //region TIMER /** * Returns the chosen numeric field value of the timer. * @method get_timer_numeric_member * @param field the value to get * @param timer timer to get the values from * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ /** * Returns the chosen boolean field value of the timer. * @method get_timer_boolean_member * @param field the value to get * @param timer timer to get the values from * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.field * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['get_timer_numeric_member'] = Blockly.JavaScript['get_timer_boolean_member'] = function (block) { const field = block.getFieldValue('PROPERTY'); const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); return [`${timer}.${field}`, Blockly.JavaScript.ORDER_NONE]; }; /** * Assigns the chosen boolean field for the timer. * @method set_timer_boolean_member * @param field the value to set * @param timer timer to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ /** * Assigns the chosen numeric field for the timer. * @method set_timer_numeric_member * @param field the value to set * @param timer timer to assign values for * @param value value to set the field to * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.field = value; * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['set_timer_numeric_member'] = Blockly.JavaScript['set_timer_boolean_member'] = function (block) { const field = block.getFieldValue('PROPERTY'); const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ATOMIC); return `${timer}.${field} = ${value};\\n`; }; /** * Creates and returns a new timer. * @method create_timer * @param autoDestroy {Boolean} whether or not the timer should automatically destroy when it's done * @returns {} * &lt;pre&gt;&lt;code&gt; * game.time.create(autoDestroy) * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['create_timer'] = function (block) { const autoDestroy = block.getFieldValue('AUTO_DESTROY') === 'TRUE'; return [`game.time.create(${autoDestroy})`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Returns the chosen constant time value. * @method time_constants * @param constant which time value to return * @returns {} * &lt;pre&gt;&lt;code&gt; * constant * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['time_constants'] = function (block) { const constant = block.getFieldValue('VALUE'); return [`${constant}`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Start the chosen timer after the given amount of time. * @method start_timer * @param delay {Number} how long to wait before starting the timer * @param timer timer to start * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.start(delay); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['start_timer'] = function (block) { const delay = Blockly.JavaScript.valueToCode(block, 'DELAY', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); return `${timer}.start(${delay});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['timer_add_event'] = function (block) { const delay = Blockly.JavaScript.valueToCode(block, 'DELAY', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); const callback = block.getFieldValue('CALLBACK'); return `${timer}.add(${delay}, ${callback});\\n`; }; /** * Adds an event to the timer, to be called after the given amount of time, once the timer has started running. The delay applies only after the timer has started. * @method timer_add_event_complex * @param delay {Number} the number of milliseconds before the timer function is called * @param callback the function to call * @param timer timer to add the function call event to * @param arguments (optional) arguments to use in the function that gets called * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.add(delay, callback, undefined, arguments[if any]); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['timer_add_event_complex'] = function (block) { const delay = Blockly.JavaScript.valueToCode(block, 'DELAY', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); const callback = block.getFieldValue('CALLBACK'); let code = timerComplexHelper(block); return `${timer}.add(${delay}, ${callback}, undefined, ${code});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['timer_loop_event'] = function (block) { const delay = Blockly.JavaScript.valueToCode(block, 'DELAY', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); const callback = block.getFieldValue('CALLBACK'); return `${timer}.loop(${delay}, ${callback});\\n`; }; /** * Adds an event to the timer, to be called continuously after the given amount of time, once the timer has started running. The delay applies only after the timer has started. * @method timer_loop_event_complex * @param delay {Number} the number of milliseconds before the timer function is called * @param callback the function to call * @param timer timer to add the function call event to * @param arguments (optional) arguments to use in the function that gets called * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.add(delay, callback, arguments[if any]); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['timer_loop_event_complex'] = function (block) { const delay = Blockly.JavaScript.valueToCode(block, 'DELAY', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); const callback = block.getFieldValue('CALLBACK'); let code = timerComplexHelper(block); return `${timer}.loop(${delay}, ${callback}, ${code});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['timer_repeat_event'] = function (block) { const delay = Blockly.JavaScript.valueToCode(block, 'DELAY', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const repeatCount = Blockly.JavaScript.valueToCode(block, 'REPEAT_COUNT', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); const callback = block.getFieldValue('CALLBACK'); return `${timer}.repeat(${delay}, ${repeatCount}, ${callback});\\n`; }; /** * Adds an event to the timer, to be called continuously after the given amount of time for the given number of times, once the timer has started running. The delay applies only after the timer has started. * @method timer_loop_event_complex * @param delay {Number} the number of milliseconds before the timer function is called * @param repeatCount {Number} the number of times to call the event * @param callback the function to call * @param timer timer to add the function call event to * @param arguments (optional) arguments to use in the function that gets called * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.add(delay, repeatCount, callback, arguments[if any]); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['timer_repeat_event_complex'] = function (block) { const delay = Blockly.JavaScript.valueToCode(block, 'DELAY', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const repeatCount = Blockly.JavaScript.valueToCode(block, 'REPEAT_COUNT', Blockly.JavaScript.ORDER_ATOMIC) || '0'; const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); const callback = block.getFieldValue('CALLBACK'); let code = timerComplexHelper(block); return `${timer}.repeat(${delay}, ${repeatCount}, ${callback}, ${code});\\n`; }; /** * Destroy the timer and stops any future related events from happening. * @method timer_destroy * @param timer timer to destroy * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.destroy(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['timer_destroy'] = function (block) { const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); return `${timer}.destroy();\\n`; }; /** * Pause the timer and all future related events. * @method timer_pause * @param timer timer to pause * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.pause(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['timer_pause'] = function (block) { const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); return `${timer}.pause();\\n`; }; /** * Resumes the timer and all future related events. * @method timer_resume * @param timer timer to resume * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.resume(); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['timer_resume'] = function (block) { const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); return `${timer}.resume();\\n`; }; /** * Stops the timer, with the option to clear the related events. * @method timer_stop * @param timer timer to stop * @param clearEvents {Boolean} option to keep or remove events related to the timer * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.stop(clearEvents); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['timer_stop'] = function (block) { const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); const clearEvents = block.getFieldValue('CLEAR_EVENTS') === 'TRUE'; return `${timer}.stop(${clearEvents});\\n`; }; /** * @deprecated * @param block * @returns {} * &lt;pre&gt;&lt;code&gt; * */ Blockly.JavaScript['timer_duration'] = function (block) { const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); return [`${timer}.duration`, Blockly.JavaScript.ORDER_ATOMIC]; }; /** * Call the given function once the timer has completed and has no other events to call. * @method timer_set_on_complete_callback * @param timer timer to use * @param callback function to call * @returns {} * &lt;pre&gt;&lt;code&gt; * timer.onComplete.add(callback); * &lt;/code&gt;&lt;/pre&gt; * @memberOf Time * @block */ Blockly.JavaScript['timer_set_on_complete_callback'] = function (block) { const timer = Blockly.JavaScript.valueToCode(block, 'TIMER', Blockly.JavaScript.ORDER_ATOMIC); const callback = block.getFieldValue('CALLBACK'); return `${timer}.onComplete.add(${callback});\\n`; }; //endregion × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespaces Namespaces Animation Body Camera Circle Collision Debug DeviceButton Dynamics GameObject Graphics Groups InputHandler Keyboard Math Mouse Particles PhaserList PhaserText Point Pointer Random Rectangle Setup Sound Sprite/Image Startup States Time Util World × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Index phaser.js Generates JavaScript for phaser blocks Check out Phaser documentation for a more in depth explanation. Author: Luke Powell Aeon Williams Copyright: DigiPen Institute of Technology 2016 Source: phaser.js, line 1 × Search results Close "},"Animation.html":{"id":"Animation.html","title":"Namespace: Animation","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Animation Animation Source: phaser_objects.js, line 1219 Methods &lt;static&gt; animation_destroy_vi(object) Destroy all animations on an object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to destroy the animations of Source: phaser_objects.js, line 1458 Returns: object.animations.destroy(); &lt;static&gt; animation_next_vi(framecount, objet) Moves the animation backwards by the given number of frames. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description framecount Number number of frames to move back objet object with the animation to change Source: phaser_objects.js, line 1372 Returns: object.animations.previous(framecount); &lt;static&gt; animation_next_vi(framecount, objet) Increases the animation by the given number of frames. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description framecount Number number of frames to advance objet object with the animation to change Source: phaser_objects.js, line 1354 Returns: object.animations.next(framecount); &lt;static&gt; get_animation_boolean_field_vi(field, object) Returns the chosen boolean field value of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to get object object to get values from Source: phaser_objects.js, line 1569 Returns: object.animations.currentAnim.field &lt;static&gt; get_animation_numeric_field(field, object) Returns the chosen numeric field value of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to get object object to get values from Source: phaser_objects.js, line 1581 Returns: object.animations.currentAnim.field &lt;static&gt; get_animation_string_field(field, object) Returns the chosen string field value of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to get object object to get values from Source: phaser_objects.js, line 1593 Returns: object.animations.currentAnim.field &lt;static&gt; play_animation_vi(animation, object) Plays an existing animation based on the given tag. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description animation String the name of the animation to play object object to play the animation on Source: phaser_objects.js, line 1236 Returns: object.animations.play(animation); &lt;static&gt; set_animation_boolean_field_vi(field, object, value) Assigns the chosen boolean field for the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to set object object to assign values for value value to set the field to Source: phaser_objects.js, line 1517 Returns: object.animations.currentAnim.field = value; &lt;static&gt; set_animation_numeric_field(field, object, value) Assigns the chosen numeric field for the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to set object object to assign values for value value to set the field to Source: phaser_objects.js, line 1530 Returns: object.animations.currentAnim.field = value; &lt;static&gt; set_animation_string_field(field, object, value) Assigns the chosen string field for the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to set object object to assign values for value value to set the field to Source: phaser_objects.js, line 1544 Returns: object.animations.currentAnim.field = value; &lt;static&gt; set_frame_vi(object, frameNumber) Sets the frame for the current animation on the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set the animation frame for frameNumber Number frame to set the animation to Source: phaser_objects.js, line 1295 Returns: object.frame = frameNumber; &lt;static&gt; stop_animation_vi(object) Stops the current animation on the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to stop the animations on Source: phaser_objects.js, line 1266 Returns: object.animations.stop(); &lt;static&gt; validate_frames_vi(object, frames) Checks if the given frames are valid and exist in the object's animation. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check the animation of frames Array frames to check Source: phaser_objects.js, line 1427 Returns: object.animations.validateFrames(frames, true) × Search results Close "},"Body.html":{"id":"Body.html","title":"Namespace: Body","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Body Body Source: phaser_physics.js, line 101 Methods &lt;static&gt; body_set_size(object, width, height, offset_x, offset_y) Sets the width and height of the physics body for an object, with an offset position. Offset is based on the anchor of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set the body of width Number width to set the body to height Number height to set the body to offset_x Number the amount to move the physics body by in the x direction, based on the object's position and anchor offset_y Number the amount to move the physics body by in the y direction, based on the object's position and anchor Source: phaser_physics.js, line 331 Returns: object.body.setSize(width, height, offset_x, offset_y); &lt;static&gt; body_set_size(object, width, height) Sets the width and height of the physics body for an object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set the body of width Number width to set the body to height Number height to set the body to Source: phaser_physics.js, line 310 Returns: object.body.setSize(width, height); &lt;static&gt; debug_body(object) Renders a visual for the physics body of the object. Will appear as a semi transparent filled green rectangle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to render the body for Source: phaser_physics.js, line 105 Returns: game.debug.body(object); &lt;static&gt; get_body_boolean_field(element, object) Returns the chosen boolean field value of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description element the value to get object object to get values from Source: phaser_physics.js, line 254 Returns: object.body.element &lt;static&gt; get_body_field_point_class(field, object) Returns the chosen point field value of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the field to get the value of object object to get values from Source: phaser_physics.js, line 202 Returns: object.body.field &lt;static&gt; get_body_numeric_field(element, object) Returns the chosen numeric field value of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description element the value to get object object to get values from Source: phaser_physics.js, line 292 Returns: object.body.element &lt;static&gt; set_body_boolean_field_vi(field, object, boolean) Assigns the chosen boolean field for the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the field to set object object to assign values for boolean value to set the field to Source: phaser_physics.js, line 234 Returns: object.body.field = point; &lt;static&gt; set_body_field_point_class_vi(field, object, point) Assigns the chosen point field for the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the field to set object object to assign values for point point to set the field to Source: phaser_physics.js, line 182 Returns: object.body.field = point; &lt;static&gt; set_body_field_point_vi(field, element, value) Assigns the chosen point field element for the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the field to set element choose to assign the x or y element of the point value value to set the field to Source: phaser_physics.js, line 160 Returns: object.body.field.element = value; &lt;static&gt; set_body_numeric_field(element, object, value) Assigns the chosen numeric field for the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description element the value to set object object to assign values for value value to set the field to Source: phaser_physics.js, line 272 Returns: object.body.element = value; &lt;static&gt; stop_body(object) Sets the object's acceleration, velocity, and speed to 0. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set values for Source: phaser_physics.js, line 122 Returns: object.body.stop(); × Search results Close "},"Camera.html":{"id":"Camera.html","title":"Namespace: Camera","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Camera Camera Source: phaser_camera.js, line 1 Methods &lt;static&gt; camera_fade(colour, time) Fades the screen to the colour over the given amount of time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description colour colour to fade the screen to time Number how long to take to fade Source: phaser_camera.js, line 19 Returns: function toHexColor(color) { return color.replace(&quot;#&quot;, &quot;0x&quot;); } game.camera.fade(toHexColorFunc(colour), time, true); &lt;static&gt; camera_flash(colour, time) Fills the game with the colour specified, then fades the colour away over the given amount of time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description colour colour to show time Number how long to take to fade the colour away Source: phaser_camera.js, line 45 Returns: function toHexColor(color) { return color.replace(&quot;#&quot;, &quot;0x&quot;); } game.camera.flash(toHexColorFunc(colour), time, true); &lt;static&gt; camera_focus_on(object) Focus the camera on the given object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to focus on Source: phaser_camera.js, line 70 Returns: game.camera.focusOn(object); &lt;static&gt; camera_focus_on_xy(posX, posY) Focus the camera on the given location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description posX Number x position to focus on posY Number y position to focus on Source: phaser_camera.js, line 86 Returns: game.camera.focusOnXY(posX, posY); &lt;static&gt; camera_reset() Resets the camera by making it focus back to 0,0 and unfollowing all objects. Also resets any camera effects. Check out Phaser documentation for a more in depth explanation. Source: phaser_camera.js, line 104 Returns: game.camera.reset(); &lt;static&gt; camera_reset_fx() Resets any active camera effects. Check out Phaser documentation for a more in depth explanation. Source: phaser_camera.js, line 118 Returns: game.camera.resetFX(); &lt;static&gt; camera_set_bounds_to_world() Updates the camera bounds to match the game world bounds. Check out Phaser documentation for a more in depth explanation. Source: phaser_camera.js, line 130 Returns: game.camera.setBoundsToWorld(); &lt;static&gt; camera_set_position(posX, posY) Sets the game camera position. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description posX Number x position for the camera posY Number y position for the camera Source: phaser_camera.js, line 144 Returns: game.camera.setPosition(posX, posY); &lt;static&gt; camera_set_size(width, height) Sets the size of the camera viewing rectangle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description width Number the width of the camera view port height Number the height of the camera view port Source: phaser_camera.js, line 162 Returns: game.camera.setSize(width, height); &lt;static&gt; camera_shake(intensity, direction, duration) Creates a camera shake effect by moving the camera randomly at the given intensity for the given amount of time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description intensity Number how much the camera should move while shaking direction which direction the camera should shake duration Number how long the camera should shake Source: phaser_camera.js, line 180 Returns: game.camera.shake(intensity, duration, true, Phaser.Camera.direction); &lt;static&gt; camera_unfollow() Stops the camera from following all objects. Check out Phaser documentation for a more in depth explanation. Source: phaser_camera.js, line 200 Returns: game.camera.unfollow(); &lt;static&gt; game_camera() Returns the game camera. Check out Phaser documentation for a more in depth explanation. Source: phaser_camera.js, line 5 Returns: game.camera × Search results Close "},"Circle.html":{"id":"Circle.html","title":"Namespace: Circle","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Circle Circle Source: phaser_geometry.js, line 832 Methods &lt;static&gt; circle_circumference(circle) Returns the circumference of the circle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description circle circle to get circumference of Source: phaser_geometry.js, line 982 Returns: circle.circumference() &lt;static&gt; circle_circumference_point(circle, degrees) Returns a point containing the coordinates of the point on the circumference of the circle based on the given angle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description circle circle to get values from degrees Number angle to get the point at Source: phaser_geometry.js, line 998 Returns: circle_circumference_point &lt;static&gt; circle_clone(circle) Returns a new circle object with the same properties as the original. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description circle circle to clone Source: phaser_geometry.js, line 930 Returns: circle.clone() &lt;static&gt; circle_contains(circle, x, y) Returns true/false if the given x/y coordinate can be found within the circle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description circle circle to check x Number the x value to check y Number the y value to check Source: phaser_geometry.js, line 946 Returns: circle.contains(x, y) &lt;static&gt; circle_create(x, y, diameter) Returns a circle with the given properties. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number x coordinate to create the circle at y Number y coordinate to create the circle at diameter Number diameter of the circle Source: phaser_geometry.js, line 836 Returns: new Phaser.Circle(x, y, diameter) &lt;static&gt; circle_get_numeric_field(object, field) Returns the chosen numeric field value of the circle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to get values from field the field to get values of Source: phaser_geometry.js, line 856 Returns: object.field &lt;static&gt; circle_intersects(circle_a, circle_b) Returns true/false if the two circle objects intersect, determined by the radius distances between the two. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description circle_a first circle to check circle_b second circle to check Source: phaser_geometry.js, line 894 Returns: Phaser.Circle.intersects(circle_a, circle_b) &lt;static&gt; circle_intersects_rectangle(circle, rectangle) Returns true/false if the circle and rectangle objects intersect. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description circle circle to check rectangle rectangle to check Source: phaser_geometry.js, line 912 Returns: Phaser.Circle.intersectsRectangle(circle, rectangle) &lt;static&gt; circle_set_numeric_field(object, field, value) Assign the chosen numeric field of the circle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set the value for field the field to set value Number value to set the field to Source: phaser_geometry.js, line 874 Returns: object.field = value; &lt;static&gt; cirlce_random(circle) Returns a point containing random values of x and y found within the circle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description circle circle to get values from Source: phaser_geometry.js, line 966 Returns: circle.random() × Search results Close "},"Collision.html":{"id":"Collision.html","title":"Namespace: Collision","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Collision Collision Source: phaser_physics.js, line 702 Methods &lt;static&gt; check_collision(direction, collide) Enables/disables objects with physics enabled to collide with the world in the given direction. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description direction direction to set the property for collide Boolean sets collision in the direction to true or false Source: phaser_physics.js, line 904 Returns: game.physics.arcade.checkCollision.direction = collide; &lt;static&gt; check_overlap_vi_procedure_field(object1, object2, functionName) Checks if two objects overlap, and calls the function if they are. No physics is applied. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object1 first object to check object2 second object to check functionName function to call if the objects are overlapping Source: phaser_physics.js, line 779 Returns: game.physics.arcade.overlap(object1, object2, functionName); &lt;static&gt; collide_boolean(object1, object2) Checks if two objects are colliding, separates them if they are, and returns true/false. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object1 first object to check object2 second object to check Source: phaser_physics.js, line 837 Returns: game.physics.arcade.collide(object1, object2) &lt;static&gt; collide_function_field(object1, object2, functionName) Checks if two objects are colliding, separates them if they are, and calls the function. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object1 first object to check object2 second object to check functionName function to call if the objects are colliding Source: phaser_physics.js, line 817 Returns: game.physics.arcade.collide(object1, object2, functionName); &lt;static&gt; collide_vi(object1, object2) Checks if two objects are colliding, and separates them if they are. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object1 first object to check object2 second object to check Source: phaser_physics.js, line 868 Returns: game.physics.arcade.collide(object1, object2); &lt;static&gt; collide_with_world_bounds_vi(object, collide) Enables/disables collision between an object and the bounds of the world. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set collision for collide Boolean enables/disables the collision Source: phaser_physics.js, line 733 Returns: object.body.collideWorldBounds = collide; &lt;static&gt; collision_get_objects_at_location_function(group, x, y, functionName) Returns a list of objects from the group that are at the x/y location, calling the given function on the ones that are there. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to check x Number x location to check y Number y location to check functionName function to call Source: phaser_physics.js, line 982 Returns: game.physics.arcade.getObjectsAtLocation(x, y, group, functionName); &lt;static&gt; get_objects_at_location(group, x, y) Returns a list of objects from the group that are at the x/y location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to check x Number x location to check y Number y location to check Source: phaser_physics.js, line 962 Returns: game.physics.arcade.getObjectsAtLocation(x, y, group); &lt;static&gt; get_objects_under_pointer(pointer, group) Returns a list of objects from the given group that are currently underneath the mouse pointer. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointer mouse pointer to check group group to check Source: phaser_physics.js, line 923 Returns: game.physics.arcade.getObectsUnderPointer(pointer, group); &lt;static&gt; is_body_touching_vi(object, direction) Returns true if something is touching the object in the specified direction. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check direction direction to check Source: phaser_physics.js, line 886 Returns: object.body.touching.direction &lt;static&gt; overlap_boolean(object1, object2) Returns true/false if two objects are overlapping. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object1 first object to check object2 second object to check Source: phaser_physics.js, line 799 Returns: game.physics.arcade.overlap(object1, object2) &lt;static&gt; physics_intersects(lhs, rhs) Returns a Boolean if the two objects are intersecting. Checks for intersection of the object's bodies. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description lhs object to check rhs object to check Source: phaser_physics.js, line 1005 Returns: game.physics.arcade.intersects(lhs, rhs); × Search results Close "},"Debug.html":{"id":"Debug.html","title":"Namespace: Debug","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Debug Debug Source: phaser_utility.js, line 1 Methods &lt;static&gt; debug_body_render(object, colour, filled) Makes the physics body for the object visible. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to display the body of colour colour to display the body with filled Boolean whether or not the body should display as stroked or filled Source: phaser_utility.js, line 117 Returns: game.debug.body(object, colour, filled); &lt;static&gt; debug_camera(camera, colour) Makes the game camera target and deadzone visible. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description camera camera to display properties of colour colour to display the properties with Source: phaser_utility.js, line 138 Returns: game.debug.camera(camera, colour); &lt;static&gt; debug_camera_info(x, y, colour) Displays information about the camera at the given location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number x coordinate to display the information at y Number y coordinate to display the information at colour colour to display the information with Source: phaser_utility.js, line 156 Returns: game.debug.cameraInfo(game.camera, x, y, colour); &lt;static&gt; debug_geom(object, colour, filled) Renders a geometry object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to render colour colour to render the object with filled Boolean whether or not to leave the object filled or stroked Source: phaser_utility.js, line 45 Returns: game.debug.geom(object, colour, filled); &lt;static&gt; debug_input_info(x, y, colour) Display information about the mouse at the given location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number x coordinate to display the information at y Number y coordinate to display the information at colour colour to display the information with Source: phaser_utility.js, line 177 Returns: game.debug.inputInfo(x, y, colour); &lt;static&gt; debug_key(dropdown_key, x, y, colour) Display information about the key at the given location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description dropdown_key key to display information of x Number x coordinate to display the information at y Number y coordinate to display the information at colour colour to display the information with Source: phaser_utility.js, line 198 Returns: game.debug.key(game.input.keyboard.addKey(Phaser.Keyboard.dropdown_key), x, y); &lt;static&gt; debug_rectangle(rect, colour) Display a rectangle with the given properties. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description rect rectangle to display colour colour to display the rectangle with Source: phaser_utility.js, line 235 Returns: game.debug.rectangle(rect, colour); &lt;static&gt; debug_sound_info(sound, x, y, colour) Display information about the sound at the given location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sound sound to display information of x Number x coordinate to display the information at y Number y coordinate to display the information at colour colour to display the information with Source: phaser_utility.js, line 269 Returns: game.debug.soundInfo(sound, x, y, colour); &lt;static&gt; debug_sprite(object, x, y) Display all information about the sprite object and it's properties. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to display information about x Number x coordiante to display the information at y Number y coordinate to display the information at Source: phaser_utility.js, line 66 Returns: game.debug.spriteInfo(object, x, y); &lt;static&gt; debug_sprite_coords(sprite, x, y) Display the sprite object's coordinates at the given location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sprite sprite to display the coordinates of x Number x coordinate to display the information at y Number y coordinate to display the information at Source: phaser_utility.js, line 292 Returns: game.debug.spriteCoords(sprite, x, y, colour); &lt;static&gt; debug_sprite_info(sprite, x, y) Display information about the sprite object at the given location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sprite sprite to display information of x Number x coordinate to display the information at y Number y coordinate to display the information at Source: phaser_utility.js, line 315 Returns: game.debug.spriteInfo(sprite, x, y, colour); &lt;static&gt; debug_text(text, x, y, colour) Display the text at the given location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description text text to display x Number x coordinate to display the information at y Number y coordinate to display the information at colour colour to display the information with Source: phaser_utility.js, line 338 Returns: game.debug.text(text, x, y, colour); &lt;static&gt; disable_step() Disables stepping through the game loop. Check out Phaser documentation for a more in depth explanation. Source: phaser_utility.js, line 18 Returns: game.disableStep(); &lt;static&gt; Display all information about the object's physics body.(object, x, y, colour) undefined Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to display body information of x Number x coordiante to display the information at y Number y coordinate to display the information at colour colour to display the information with Source: phaser_utility.js, line 94 Returns: game.debug.bodyInfo(object, x, y, colour); &lt;static&gt; enable_step() Enables stepping through the game loop one frame at a time. Must use game.step() Check out Phaser documentation for a more in depth explanation. Source: phaser_utility.js, line 5 Returns: game.enableStep(); &lt;static&gt; step() Steps through the game loop one frame at a time. Check out Phaser documentation for a more in depth explanation. Source: phaser_utility.js, line 31 Returns: game.step(); × Search results Close "},"DeviceButton.html":{"id":"DeviceButton.html","title":"Namespace: DeviceButton","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: DeviceButton DeviceButton Source: phaser_input.js, line 893 Methods &lt;static&gt; device_button_get_boolean_field(object, field) Returns the chosen boolean field value of the chosen button on the pointer. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object button to get the values from field the value to get Source: phaser_input.js, line 897 Returns: object.field &lt;static&gt; device_button_get_numeric_field(object, field) Returns the chosen numeric field value of the chosen button on the pointer. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object button to get the values from field the value to get Source: phaser_input.js, line 909 Returns: object.field &lt;static&gt; device_button_just_pressed(object) Returns true/false if the chosen button on the pointer was pressed within the last 250 milliseconds. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object button to check Source: phaser_input.js, line 939 Returns: object.justPressed() &lt;static&gt; device_button_just_pressed_complex(object, duration) Returns true/false if the chosen button on the pointer was pressed within the given amount of time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object button to check duration Number the duration to check Source: phaser_input.js, line 973 Returns: object.justPressed(duration) &lt;static&gt; device_button_just_released(object) Returns true/false if the chosen button on the pointer was released within the last 250 milliseconds. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object button to check Source: phaser_input.js, line 923 Returns: object.justReleased() &lt;static&gt; device_button_just_released_complex(object, duration) Returns true/false if the chosen button on the pointer was released within the given amount of time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object button to check duration Number the duration to check Source: phaser_input.js, line 955 Returns: object.justReleased(duration) × Search results Close "},"Dynamics.html":{"id":"Dynamics.html","title":"Namespace: Dynamics","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Dynamics Dynamics Source: phaser_physics.js, line 454 Methods &lt;static&gt; acceleration_from_rotation(rotation, speed) Calculates, the acceleration based on rotation, and returns a point that contains the acceleration x value and the acceleration y value. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description rotation Number the angle in radians speed Number the speed the object will move Source: phaser_physics.js, line 493 Returns: game.physics.arcade.accelerationFromRotation(rotation, speed) &lt;static&gt; get_physics_boolean_field(field) Returns the chosen Boolean field value of the game's physics. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the field to get the value of Source: phaser_physics.js, line 673 Returns: game.physics.arcade.field &lt;static&gt; get_physics_point_field(field) Returns the chosen point field value of the game's physics. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the field to get the value of Source: phaser_physics.js, line 684 Returns: game.physics.arcade.field &lt;static&gt; move_to_object(object, destinationObject, speed, maximumTime) Moves the first object to the second object at the given speed. Speed will be adjusted to reach the destination object within the given maximum time. If the destination object moves, the target location will not change. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to move destinationObject object to move to speed Number speed for the object to move at maximumTime Number maximum amount of time to take to move Source: phaser_physics.js, line 471 Returns: game.physics.arcade.moveToObject(object, destinationObject, speed, maximumTime); &lt;static&gt; physics_accelerate_to_location(object, x, y, speed, x_max, y_max) Accelerates the object to the given location at the given speed, with the maximum given velocity. The object will start at the given speed, and accelerate up to the maximum velocity towards the location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to move x Number x position of the location to move to y Number y position of the location to move to speed Number the speed the object will move at x_max Number the maximum velocity in the x direction the object can reach y_max Number the maximum velocity in the y direction the object can reach Source: phaser_physics.js, line 559 Returns: game.physics.arcade.accelerateToXY(object, x, y, speed, x_max, y_max); &lt;static&gt; physics_accelerate_to_object(object, target, speed, x_max, y_max) Accelerates the object to the given object's location at the given speed, with the maximum given velocity. The object will start at the given speed, and accelerate up to the maximum velocity towards the location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to move target the target object to move to speed Number the speed the object will move at x_max Number the maximum velocity in the x direction the object can reach y_max Number the maximum velocity in the y direction the object can reach Source: phaser_physics.js, line 611 Returns: game.physics.arcade.accelerateToObject(object, target, speed, x_max, y_max); &lt;static&gt; physics_accelerate_to_pointer(object, pointer, speed, x_max, y_max) Accelerates the object to the mouse pointer at the given speed, with the maximum given velocity. The object will start at the given speed, and accelerate up to the maximum velocity towards the location. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to move pointer the mouse pointer to move to speed Number the speed the object will move at x_max Number the maximum velocity in the x direction the object can reach y_max Number the maximum velocity in the y direction the object can reach Source: phaser_physics.js, line 586 Returns: game.physics.arcade.accelerateToPointer(object, pointer, speed, x_max, y_max); &lt;static&gt; physics_move_to_location(object, x, y, speed, time) Move the object to the given location at the given speed, taking no longer than the maximum given time. Speed will be adjusted so the object reaches the location within the given time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to move x Number x position of the location to move to y Number y position of the location to move to speed Number the speed the object will move at time Number maximum time for the object to reach the location Source: phaser_physics.js, line 511 Returns: game.physics.arcade.moveToXY(object, x, y, speed, time); &lt;static&gt; physics_move_to_pointer(object, pointer, speed, time) Move the object to the mouse pointer at the given speed, taking no longer than the maximum given time. Speed will be adjusted so the object reaches the location within the given time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to move pointer the mouse pointer to move to speed Number the speed the object will move at time Number maximum time for the object to reach the location Source: phaser_physics.js, line 536 Returns: game.physics.arcade.moveToPointer(object, speed, pointer, time); &lt;static&gt; set_physics_boolean_field(field, value) Assign the chosen Boolean field for the game's physics. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the field to set value Boolean value to set the field to Source: phaser_physics.js, line 636 Returns: game.physics.arcade.field = value; &lt;static&gt; set_physics_point_field(field, value) Assigns the chosen point field for the game's physics. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the field to set value value to set the field to Source: phaser_physics.js, line 654 Returns: game.physics.arcade.field.copyFrom(value); × Search results Close "},"GameObject.html":{"id":"GameObject.html","title":"Namespace: GameObject","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: GameObject GameObject Source: phaser_objects.js, line 2009 Methods &lt;static&gt; camera_follow_vi(object) Makes the game camera follow the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object for the camera to follow Source: phaser_objects.js, line 2231 Returns: game.camera.follow(object); &lt;static&gt; camera_follow_vi_complex(object, lerpX, lerpY, style) Makes the game camera follow the object, with a specific style of following. Lerp designates how much linear interpolation to use when horizontally tracking the object. The closer the values is to 1, the faster the camera will track. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object for the camera to follow lerpX Number linear interpolation in the x direction lerpY Number linear interpolation in the y direction style the style of the camera following Source: phaser_objects.js, line 2277 Returns: game.camera.follow(object, style, lerpX, lerpY); &lt;static&gt; camera_follow_vi_styled(object, style) Makes the game camera follow the object, with a specific style of following. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object for the camera to follow style the style of the camera following Source: phaser_objects.js, line 2259 Returns: game.camera.follow(object, Phaser.Camera.style); &lt;static&gt; destroy_object(object) Deletes everything about the game object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to destroy Source: phaser_objects.js, line 2189 Returns: object.destroy(); &lt;static&gt; faint_object(object) Sets the values of game object alive, exists, and visible to false. Does not actually destroy the object or free it from memory. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to faint Source: phaser_objects.js, line 2173 Returns: object.faint(); &lt;static&gt; get_game_object_boolean_field(object, field) Returns the chosen boolean field value for the game object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to get values from field the field to get the value of Source: phaser_objects.js, line 2091 Returns: object.field &lt;static&gt; get_game_object_numeric_field(object, field) Returns the chosen point numeric value for the game object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to get the values from field the field to get the value of Source: phaser_objects.js, line 2129 Returns: object.field &lt;static&gt; get_physics_point_field(object, field) Returns the chosen point field value of the game object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to get values from field the field to get the value of Source: phaser_objects.js, line 2039 Returns: object.field &lt;static&gt; move_by(object, x, y) Move the position of the object by the given amount, relative to the object's current position. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to move x Number number of pixels in the x direction to move y Number number of pixels in the y direction to move Source: phaser_objects.js, line 2447 Returns: object.position.add(x, y); &lt;static&gt; reset(object, x, y) Moves the game object to the given coordinates, and sets properties fresh, exists, visible, and renderable to true. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to reset x Number x position to move the object to y Number y position to move the object to Source: phaser_objects.js, line 2396 Returns: object.reset(x, y); &lt;static&gt; revive(object) Brings a fainted object back to &quot;life&quot;. Sets alive, exists, and visible to true. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to revive Source: phaser_objects.js, line 2416 Returns: object.revive(); &lt;static&gt; rotate(object, value_angle) Rotates the object by the number of degrees. 0 to 180 rotates clockwise, 0 to -180 rotates counterclockwise. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to rotate value_angle Number number of degrees to rotate by Source: phaser_objects.js, line 2353 Returns: object.angle += value_angle; &lt;static&gt; set_game_object_boolean_field_vi(object, field, value) Assigns the chosen boolean field for the game object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set the field for field the field to set value value to set the field to Source: phaser_objects.js, line 2071 Returns: object.field = value; &lt;static&gt; set_game_object_numeric_field(object, field, value) Assigns the chosen numeric value for the game object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set the field for field the field to set value value to set the field to Source: phaser_objects.js, line 2109 Returns: object.field = value; &lt;static&gt; set_game_object_point_field(field, point, object) Assigns the chosen point field for the game object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the field to set point point to set the field to object object to set the field for Source: phaser_objects.js, line 2024 Returns: object.field.copyFrom(point); × Search results Close "},"Graphics.html":{"id":"Graphics.html","title":"Namespace: Graphics","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Graphics Graphics Source: phaser_graphics.js, line 1 Methods &lt;static&gt; create_graphics_object(x, y) Adds a graphics object to use to draw primitive shapes. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number x position of the new graphics object y Number y position of the new graphics object Source: phaser_graphics.js, line 5 Returns: game.add.graphics(x, y); &lt;static&gt; draw_circle(x, y, diameter) Draws a circle. Use inside of draw_shapes_with_colour Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number x position of the rectangle y Number y position of the rectangle diameter Number the diameter of the rectangle Source: phaser_graphics.js, line 78 Returns: graphicsVar.drawCircle(x, y, diameter); &lt;static&gt; draw_rectangle(x, y, width, height) Draws a rectangle. Use inside of draw_shapes_with_colour Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number x position of the rectangle y Number y position of the rectangle width Number the width of the rectangle height Number the height of the rectangle Source: phaser_graphics.js, line 54 Returns: graphicsVar.drawRect(x, y, width, height); &lt;static&gt; draw_shapes_with_colour(colour, graphics) Enables graphics filling for shapes. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description colour the colour to fill the shapes with graphics the graphics object to use Source: phaser_graphics.js, line 24 Returns: graphics.beginFill(toHexColor(colour)); (shapes to fill) graphics.endFill(); × Search results Close "},"Groups.html":{"id":"Groups.html","title":"Namespace: Groups","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Groups Groups Source: phaser_objects.js, line 861 Methods &lt;static&gt; add_to_group(object, group) Adds the given object to the front of the group. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object that gets added to the group group group that the object is getting added to Source: phaser_objects.js, line 976 Returns: group.add(object); &lt;static&gt; add_to_world(object) Adds the object to the top of the World group. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to add to the group Source: phaser_objects.js, line 1203 Returns: game.world.add(object); &lt;static&gt; create_group() Creates a container to hold multiple sprites. Assign to a variable for future use. Check out Phaser documentation for a more in depth explanation. Source: phaser_objects.js, line 904 Returns: game.add.group(); &lt;static&gt; create_object_in_group_vi(x, y, tag) Creates an object at a position with the given tag, and adds it to the front of the group. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number the x coordinate to display the new object at, relative to the position of the group y Number the y coordinate to display the new object at, relative to the position of the group tag String the tag of the image to assign to the object Source: phaser_objects.js, line 883 Returns: group.create(x, y, tag); &lt;static&gt; create_object_in_group_with_frame_vi(x, y, frame, tag, group) Creates a new object from the tag and adds it to the front of the group. Assign to a variable for future use. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number the x position for the object to be displayed at y Number the y position for the object to be displayed at frame Number the frame of the sprite sheet to display at the start tag String the sprite to display on the object group the group to add the object to Source: phaser_objects.js, line 937 Returns: group.create(x, y, tag, frame); &lt;static&gt; destroy_group(group, handleChildren) Removes all objects and deletes the group, with the option to delete the objects as well. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to destroy handleChildren option to delete all containing objects Source: phaser_objects.js, line 1049 Returns: group.destroy(handleChildren); &lt;static&gt; group_contains(group, object) Figures out if the group contains the object, and returns true or false. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to check object object to check Source: phaser_objects.js, line 1014 Returns: group.contains(child); &lt;static&gt; group_count_alive_dead(group, state) Figures out how many objects are alive or fainted in the group, and returns the number. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to check state determines if you are checking alive or fainted. Source: phaser_objects.js, line 1032 Returns: group.count(state); &lt;static&gt; group_get_all(group) Returns all objects in the group, to make changes or get information from them all at the same time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to get all objects from Source: phaser_objects.js, line 1067 Returns: group.getAll(); &lt;static&gt; group_get_at(group, index) Returns the object at the position of the given index in the group. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to get the object from index Number position of the object in the group Source: phaser_objects.js, line 1083 Returns: group.getAt(index); &lt;static&gt; group_get_closest_to(group, object) Returns the object in the group physically closest to the given object, based on their x/y coordinates. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to get the object from object object to base the position from Source: phaser_objects.js, line 1101 Returns: group.getClosestTo(object); &lt;static&gt; group_get_first_alive_fainted(group, mode) Returns the first object closest to the front of the group that is alive/fainted. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to get the object from mode determines if you are checking for an alive or fainted object Source: phaser_objects.js, line 1135 Returns: group.getFirstMode(); &lt;static&gt; group_get_random(group) Returns a randomly chosen object from the group. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to get the object from Source: phaser_objects.js, line 1153 Returns: group.getRandom(); &lt;static&gt; group_get_random_exists(group) Returns a randomly chosen object from the group that has exists set to true. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to get the object from Source: phaser_objects.js, line 1169 Returns: group.getRandomExists(); &lt;static&gt; group_remove_all(group, deleteObjects) Remove all members from the group, with the option to delete them as well. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to remove the objects from deleteObjects Boolean option to delete the objects after removing them from the group Source: phaser_objects.js, line 1185 Returns: group.removeAll(deleteObjects); &lt;static&gt; remove_from_group(object, group, destroy) Removes the given object from the group, with the option to remove it from the game as well. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object that gets removed from the group group group that the object is getting removed from destroy Boolean option to remove the object from the game Source: phaser_objects.js, line 994 Returns: group.remove(object, destroy); × Search results Close "},"InputHandler.html":{"id":"InputHandler.html","title":"Namespace: InputHandler","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: InputHandler InputHandler Source: phaser_input.js, line 228 Methods &lt;static&gt; get_input_handler_boolean_field(field, object) Returns the chosen boolean field value of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to get object object to get values from Source: phaser_input.js, line 303 Returns: object.input.field &lt;static&gt; get_input_handler_numeric_field(field, object) Returns the chosen numeric field value of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to get object object to get values from Source: phaser_input.js, line 315 Returns: object.input.field &lt;static&gt; get_input_handler_point_field(field, object) Returns the chosen point field value of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to get object object to get values from Source: phaser_input.js, line 327 Returns: object.input.field &lt;static&gt; input_handler_bounds_rect_set(object, rect) Sets the boundary of where the sprite is restricted while being dragged. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set the boundary for rect rectangle that defines the boundary Source: phaser_input.js, line 348 Returns: object.input.boundsRect = rect; &lt;static&gt; input_handler_check_pixel(x, y, object) Returns true/false if the alpha value at the given location is greater than or equal to the object's pixelPerfectAlpha value. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number x coordinate to check y Number y coordinate to check object object to check Source: phaser_input.js, line 524 Returns: object.input.checkPixel(x, y) &lt;static&gt; input_handler_check_pointer_down(pointer, object) Returns true/false if the pointer is currently clicking on the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointer pointer to check object object to check Source: phaser_input.js, line 406 Returns: input.checkPointerDown(pointer) &lt;static&gt; input_handler_check_pointer_over(pointer, object) Returns true/false if the pointer is on top of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointer pointer to check object object to check Source: phaser_input.js, line 424 Returns: object.input.checkPointerOver(pointer) &lt;static&gt; input_handler_destroy(object) Destroys the input handler for the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to destroy the handler for Source: phaser_input.js, line 823 Returns: object.input.destroy(); &lt;static&gt; input_handler_disable_drag(object) Stops the object from being dragged. If it is currently being dragged, it will be stopped immediately. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to disable drag on Source: phaser_input.js, line 442 Returns: object.input.disableDrag(); &lt;static&gt; input_handler_disable_snap(object) Stops the object from snapping to a grid while being dragged and released. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to disable snap for Source: phaser_input.js, line 508 Returns: object.input.disableSnap(); &lt;static&gt; input_handler_down_duration(object) Returns the number of milliseconds the mouse has been clicking on the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check Source: phaser_input.js, line 642 Returns: object.input.downDuration() &lt;static&gt; input_handler_enable(object) Enables an object to use input handler methods and events. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to enable the input handler on Source: phaser_input.js, line 232 Returns: object.inputEnabled = true; &lt;static&gt; input_handler_enable_drag(object) Allows the object to be clicked and dragged by the mouse. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to enable dragging on Source: phaser_input.js, line 366 Returns: object.input.enableDrag(); &lt;static&gt; input_handler_enable_drag_complex(object, center, top, pixel, alpha) Allows the object to be clicked and dragged by the mouse, with customizable options. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to enable dragging on center Boolean If false the Sprite will drag from where you click it minus the dragOffset. If true it will center itself to the tip of the mouse pointer top Boolean If true the object will be displayed on top of everything else pixel Boolean If true it will use a pixel perfect test to see if you clicked the object. False uses the bounding box alpha Boolean If pixel perfect is true, this specifies the alpha level needed for collision to be processed Source: phaser_input.js, line 382 Returns: object.input.enableDrag(center, top, pixel, alpha); &lt;static&gt; input_handler_enable_snap(object, x, y) Make the object snap to the given x/y grid when being dragged or released. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to snap x Number the width of the grid to snap to y Number the height of the grid to snap to Source: phaser_input.js, line 458 Returns: object.input.enableSnap(x, y); &lt;static&gt; input_handler_enable_snap_complex(object, x, y, drag, release, offset_x, offset_y) Make the object snap to the given x/y grid when being dragged or released, with customizable options. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to snap x Number the width of the grid to snap to y Number the height of the grid to snap to drag Boolean makes the object snap to the grid while being dragged release Boolean makes the object snap to the grid when released offset_x Number offsets the top left starting point of the grid offset_y Number offsets the top left starting point of the grid Source: phaser_input.js, line 479 Returns: object.input.enableSnap(x, y, drag, release, offset_x, offset_y); &lt;static&gt; input_handler_is_pixel_perfect(object) Returns true/false if the object is using pixel perfect checking. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check Source: phaser_input.js, line 544 Returns: object.input.isPixelPerfect() &lt;static&gt; input_handler_just_out(object, time) Returns true/false if the pointer left the object's bounds within the given duration. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check time Number duration to check Source: phaser_input.js, line 724 Returns: object.input.justOut(0, time) &lt;static&gt; input_handler_just_over(object, time) Returns true/false if the mouse has entered the object's bounds within the given time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check time Number time to check Source: phaser_input.js, line 624 Returns: object.input.justOver(0, time) &lt;static&gt; input_handler_just_pressed(object, time) Returns true/false if the object was clicked on within the given time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check time Number the duration to check Source: phaser_input.js, line 560 Returns: object.input.justPressed(0, time) &lt;static&gt; input_handler_just_released(object, time) Returns true/false if the object was released on within the given time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check time Number the duration to check Source: phaser_input.js, line 578 Returns: object.input.justReleased(0, time) &lt;static&gt; input_handler_over_duration(object) Returns the number of milliseconds the mouse has been hovering over the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check Source: phaser_input.js, line 596 Returns: object.input.overDuration() &lt;static&gt; input_handler_pointer_down(object) Returns true/false if the pointer is down. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check Source: phaser_input.js, line 674 Returns: object.input.pointerDown() &lt;static&gt; input_handler_pointer_dragged(object) Returns true/false if the object is currently being dragged. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check Source: phaser_input.js, line 839 Returns: object.input.pointerDragged() &lt;static&gt; input_handler_pointer_out(object) Returns true/false if the pointer is outside of the object's bounds. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check Source: phaser_input.js, line 742 Returns: object.input.pointerOut() &lt;static&gt; input_handler_pointer_position(object) Returns a point containing the x &amp; y coordinates of the pointer, relative to the top-left of the anchor of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check Source: phaser_input.js, line 790 Returns: new Phaser.Point(object.input.pointerX(), object.input.pointerY()) &lt;static&gt; input_handler_pointer_up(object) Returns true/false if the pointer is up. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check Source: phaser_input.js, line 658 Returns: object.input.pointerUp() &lt;static&gt; input_handler_pointer_x(object) Returns the x coordinate of the pointer, relative to the top-left of anchor of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check Source: phaser_input.js, line 758 Returns: object.input.pointerX() &lt;static&gt; input_handler_pointer_y(object) Returns the y coordinate of the pointer, relative to the top-left of anchor of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check Source: phaser_input.js, line 774 Returns: object.input.pointerY() &lt;static&gt; input_handler_reset(object) Resets the input handler for the object, and disables it. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to reset the input handler for Source: phaser_input.js, line 807 Returns: object.input.reset(); &lt;static&gt; input_handler_set_drag_lock(object, horizontal, vertical) Locks dragging for the object in certain directions. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to lock dragging for horizontal Boolean enables/disables the object from being dragged horizontally vertical Boolean enables/disables the object from being dragged vertically Source: phaser_input.js, line 855 Returns: object.input.setDragLock(horizontal, vertical); &lt;static&gt; input_handler_start(object, priority) Starts the Input Handler. This is automatically called if input is enabled on an object. Higher priority objects take click priority when objects are stacked on top of each other. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to start input handler for priority Number the priority of the object Source: phaser_input.js, line 690 Returns: object.input.start(priority); &lt;static&gt; input_handler_stop(object) Stops the Input Handler from running on the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to affect Source: phaser_input.js, line 708 Returns: object.input.stop(); &lt;static&gt; set_input_handler_boolean_field(field, object, value) Assigns the chosen boolean field for the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to set object object to assign values for value value to set the field to Source: phaser_input.js, line 248 Returns: object.input.field = value; &lt;static&gt; set_input_handler_numeric_field(field, object, value) Assigns the chosen numeric field for the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to set object object to assign values for value value to set the field to Source: phaser_input.js, line 261 Returns: object.input.field = value; &lt;static&gt; set_input_handler_point_field(field, object, value) Assigns the chosen point field for the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to set object object to assign values for value value to set the field to Source: phaser_input.js, line 283 Returns: object.input.field.copyFrom(value); × Search results Close "},"Keyboard.html":{"id":"Keyboard.html","title":"Namespace: Keyboard","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Keyboard Keyboard Source: phaser_input.js, line 1 Methods &lt;static&gt; add_key(key) Creates a Phaser key object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description key keycode of the key to create Source: phaser_input.js, line 32 Returns: game.input.keyboard.addKey(Phaser.Keyboard.key) &lt;static&gt; get_key_boolean_field(field, key) Returns the chosen boolean field value of the key. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to get key key to get values from Source: phaser_input.js, line 48 Returns: key.field &lt;static&gt; get_key_numeric_field(field, key) Returns the chosen numeric field value of the key. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to get key key to get values from Source: phaser_input.js, line 60 Returns: key.field &lt;static&gt; is_key_down(key) Returns true/false about whether or not the given key is currently being pressed down. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description key key to check Source: phaser_input.js, line 16 Returns: game.input.keyboard.isDown(Phaser.Keyboard.key) &lt;static&gt; key_just_pressed(key) Returns true/false if the given key was pressed down this update tick. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description key key to check Source: phaser_input.js, line 80 Returns: key.justPressed() &lt;static&gt; key_just_released(key) Returns true/false if the given key was released down this update tick. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description key key to check Source: phaser_input.js, line 96 Returns: key.justReleased() &lt;static&gt; key_reset(key, hard) Resets the state of the key. Hard reset removes any callback methods associated with it. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description key key to reset hard Boolean whether or not to hard reset the key Source: phaser_input.js, line 112 Returns: key.reset(hard) &lt;static&gt; key_up_duration(key, duration) Returns true/false if the given key was released within the given amount of time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description key key to check duration Number duration within which the key is considered as just released Source: phaser_input.js, line 130 Returns: key.upDuration(duration); &lt;static&gt; key_up_duration(key, duration) Returns true/false if the given key was pressed within the given amount of time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description key key to check duration Number duration within which the key is considered as just pressed Source: phaser_input.js, line 148 Returns: key.downDuration(duration); × Search results Close "},"Math.html":{"id":"Math.html","title":"Namespace: Math","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Math Math Source: phaser_utility.js, line 361 Methods &lt;static&gt; math_deg_to_rad(degrees) Converts the given degrees to radians and returns the result. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description degrees Number the number of degrees to convert to radians. Source: phaser_utility.js, line 365 Returns: game.math.degToRad(degrees) &lt;static&gt; math_rad_to_deg(radians) Converts the given radians to degrees and returns the result. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description radians Number the number of radians to convert to degrees Source: phaser_utility.js, line 381 Returns: game.math.radToDeg(radians) &lt;static&gt; phaser_easing(ease, direction) Returns the chosen easing method in the given direction. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description ease easing method to return direction direction for the easing method to use Source: phaser_utility.js, line 639 Returns: Phasser.ease.direction &lt;static&gt; phaser_easing_linear() Returns the linear easing method. Check out Phaser documentation for a more in depth explanation. Source: phaser_utility.js, line 657 Returns: Phaser.Easing.Linear.None &lt;static&gt; phaser_game_add_tween_from(target, duration, ease, autostart, delay, repeat, yoyo, properties) Creates and returns a tween with the given properties. It will set the target to the destination value and tween to it's current value. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description target the object to add the tween to duration Number duration of the tween ease the easing function to use on the tween autostart Boolean option to automatically start the tween instead of manually calling tween.start() delay Number delay before the tween will start, in milliseconds repeat Number how many times the tween should repeat. Set to -1 to run forever yoyo Boolean option for the tween to reverse itself and play backwards properties (optional) optional properties to add to the tween Source: phaser_utility.js, line 705 Returns: game.add.tween(target).from(properties[if used], duration, ease, autostart, delay, repeat, yoyo) &lt;static&gt; phaser_game_add_tween_to(target, duration, ease, autostart, delay, repeat, yoyo, properties) Creates and returns a tween with the given properties. It will start at the current value and tween to the destination value. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description target the object to add the tween to duration Number duration of the tween ease the easing function to use on the tween autostart Boolean option to automatically start the tween instead of manually calling tween.start() delay Number delay before the tween will start, in milliseconds repeat Number how many times the tween should repeat. Set to -1 to run forever yoyo Boolean option for the tween to reverse itself and play backwards properties (optional) optional properties to add to the tween Source: phaser_utility.js, line 672 Returns: game.add.tween(target).to(properties[if used], duration, ease, autostart, delay, repeat, yoyo) &lt;static&gt; phaser_resume_tween(tween) Resumes the chosen tween. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description tween tween to resume Source: phaser_utility.js, line 772 Returns: tween.resume(); &lt;static&gt; phaser_start_tween(tween) Start the chosen tween object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description tween tween to start Source: phaser_utility.js, line 788 Returns: tween.start(); &lt;static&gt; phaser_stop_tween(tween, complete) Stop the chosen tween. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description tween tween to stop complete Boolean if true, dispatches the onComplete signal Source: phaser_utility.js, line 738 Returns: tween.stop(complete); &lt;static&gt; phaser_yoyo_tween(tween, enable, delay, index) Make the chosen tween run through the starting values and then play back in reverse. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description tween tween to yoyo enable Boolean enable/disable yoyoing on the tween delay Number the amount of time to wait until the yoyo will start index Number choose the object index on the tween to apply this to Source: phaser_utility.js, line 804 Returns: tween.yoyo(enable, delay, index); × Search results Close "},"Mouse.html":{"id":"Mouse.html","title":"Namespace: Mouse","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Mouse Mouse Source: phaser_input.js, line 166 Methods &lt;static&gt; get_active_pointer() Returns the active game pointer. Check out Phaser documentation for a more in depth explanation. Source: phaser_input.js, line 214 Returns: game.input.activePointer &lt;static&gt; get_current_mouse_position(direction) Returns the specified coordinate value of the mouse position. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description direction which coordinate of the mouse position to get Source: phaser_input.js, line 170 Returns: game.input.direction &lt;static&gt; get_mouse_position_point() Returns the mouse position as a point that contains the x/y values of the coordinates. Check out Phaser documentation for a more in depth explanation. Source: phaser_input.js, line 186 Returns: New Phaser.Point(game.input.x, game.input.y) &lt;static&gt; is_mouse_button_clicked() Returns true/false if the specified mouse button is currently being clicked. Check out Phaser documentation for a more in depth explanation. Source: phaser_input.js, line 200 Returns: game.input.mousePointer.button.isDown × Search results Close "},"Particles.html":{"id":"Particles.html","title":"Namespace: Particles","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Particles Particles Source: phaser_objects.js, line 1690 Methods &lt;static&gt; addemitter(x, y, maxparticles) Creates a particle emitter at the given location, with a total number of max particles. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number the x location of the emitter y Number the y location of the emitter maxparticles Number the total number of particles in the emitter Source: phaser_objects.js, line 1694 Returns: game.add.emitter(x, y, maxparticles) &lt;static&gt; emitters_make_particles(emitter, keys, frames, quantity, collide, collideWorldBounds) Generates new particles to be used by the emitter. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description emitter emitter to make new particles for keys String the sprite/texture to use for the particles frames Number the frames the sprites will use quantity Number the number of particles to generate collide Boolean whether or not the particles should collide with physics bodies collideWorldBounds Boolean whether or not the particles should collide with the world bounds Source: phaser_objects.js, line 1728 Returns: emitter.makeParticles(keys, frames, quantity, collide, collideWorldBounds); &lt;static&gt; emitters_set_alpha_vi(emitter, min, max, rate) Sets the alpha constraints and variations for the particles on the emitter. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description emitter emitter to change the particles of min Number the minimum value the alpha of the particles can reach max Number the maximum value the alpha of the particles can reach rate Number the rate the particles will change between min and max Source: phaser_objects.js, line 1798 Returns: emitter.setAlpha(min, max, rate); &lt;static&gt; emitters_set_gravity(emitter, particle_gravity) Sets the gravity each particle has when launched from the emitter. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description emitter emitter to set the gravity of the particles for particle_gravity Number the gravity each particle will have Source: phaser_objects.js, line 1924 Returns: emitter.gravity = particle_gravity; &lt;static&gt; emitters_set_scale_vi(emitter, minx, maxx, miny, maxy, rate) Sets the scale constraints and variations for the particles on the emitter. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description emitter emitter to change the particles of minx Number the minimum x value the scale the particles can reach maxx Number the maximum x value the scale the particles can reach miny Number the minimum y value the scale the particles can reach maxy Number the maximum y value the scale the particles can reach rate Number the rate the particles will change between min and max Source: phaser_objects.js, line 1837 Returns: emitter.setScale(minx, maxx, miny, maxy, rate); &lt;static&gt; emitters_set_speed_vi(emitter, minx, maxx, miny, maxy) Sets the maximum and minimum speeds of the particles released from the emitter. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description emitter emitter to set the speed of the particles for minx Number the minimum speed for the particles to move in the x direction maxx Number the maximum speed for the particles to move in the x direction miny Number the minimum speed for the particles to move in the y direction maxy Number the maximum speed for the particles to move in the y direction Source: phaser_objects.js, line 1883 Returns: emitter.minParticleSpeed.set(minx, miny); emitter.maxParticleSpeed.set(maxx, maxy); &lt;static&gt; emitters_start_vi(emitter, explode, lifespan, frequency, quantity) Tell the emitter to start emitting particles. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description emitter emitter to start emitting particles from explode Boolean whether the particles should burst out at once (true), or at the frequency given (false) lifespan Number how long each particle lives once emitted frequency Number the interval between the release of each particle quantity Number how many particles to emit before turning off Source: phaser_objects.js, line 1971 Returns: emitter.start(explode, lifespan, frequncy, quantity); × Search results Close "},"PhaserList.html":{"id":"PhaserList.html","title":"Namespace: PhaserList","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: PhaserList PhaserList Source: phaser_utility.js, line 397 Methods &lt;static&gt; list_find_closest(value, array) Finds the value in the list that is closest to the given value Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description value Number the search value array the list to search Source: phaser_utility.js, line 401 Returns: Phaser.ArrayUtils.findClosest(value, array) &lt;static&gt; list_get_random(array) Returns a randomly selected item from the given list. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description array list to get the value from Source: phaser_utility.js, line 419 Returns: Phaser.ArrayUtils.getRandomItem(array) &lt;static&gt; list_remove_random_item(array) Returns a random item and removes it from the list. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description array list to get the item from Source: phaser_utility.js, line 473 Returns: Phaser.ArrayUtils.removeRandomItem(array) &lt;static&gt; list_shuffle(array) Shuffles the contents of the list by changing the positions of all items. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description array list to shuffle Source: phaser_utility.js, line 489 Returns: Phaser.ArrayUtils.shuffle(array); &lt;static&gt; number_list(start, end) Creates and returns a list with every number between the given parameters. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description start Number the minimum value the list starts with end Number the maximum value the list contains Source: phaser_utility.js, line 435 Returns: Phaser.ArrayUtils.numberArray(start, end) &lt;static&gt; number_list_step(start, end, step) Creates and returns a list starting with the min value, stepping by the given value, and stopping at the max value. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description start Number the minimum value the list starts with end Number the maximum value the list starts with step Number the value to incremement/decrement by Source: phaser_utility.js, line 453 Returns: Phaser.ArrayUtils.numberArrayStep(start, end, step) × Search results Close "},"PhaserText.html":{"id":"PhaserText.html","title":"Namespace: PhaserText","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: PhaserText PhaserText Source: phaser_objects.js, line 1615 Methods &lt;static&gt; add_text_input(x, y, initial_text, size, colour) Creates a new text object and adds it to the game. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number the x coordinate to display the text at y Number the y coordinate to display the text at initial_text String the text to display size Number the font size to display the text with colour the colour to display the text with Source: phaser_objects.js, line 1619 Returns: game.add.text(x, y, initial_text, {fontSize: `${size}px`, fill: 'colour'}) &lt;static&gt; set_text_vi(object, text_string) Sets the text to display on the text object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object text object to set the text for text_string String text to display on the object Source: phaser_objects.js, line 1672 Returns: object.text = text_string; × Search results Close "},"Point.html":{"id":"Point.html","title":"Namespace: Point","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Point Point Source: phaser_geometry.js, line 200 Methods &lt;static&gt; point_create(x, y) Returns a point from the given x/y values. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number x value for the point y Number y value for the point Source: phaser_geometry.js, line 204 Returns: new Phaser.Point(x, y) &lt;static&gt; point_get_element(element, point) Returns the x or y value of the point. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description element which value to return point point to get the value from Source: phaser_geometry.js, line 222 Returns: point.element &lt;static&gt; point_set_element(element, point, value) Assigns the x or y value of the point to a number. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description element which value to set point point to set the value for value Number value to set the element to Source: phaser_geometry.js, line 240 Returns: point.element = value; &lt;static&gt; point_set_magnitude(point, value) Sets the magnitude of the point to a number. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to set the magnitude for value Number value to set the magnitude to Source: phaser_geometry.js, line 260 Returns: point.setMagnitude(value); &lt;static&gt; points_add(pointA, pointB) Adds the coordinates of two points and returns a new point with the result. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA first point to add pointB second point to add Source: phaser_geometry.js, line 278 Returns: Phaser.Point.add(pointA, pointB) &lt;static&gt; points_add_member(point, x, y) Adds the given x and y values to the point. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to add values to x Number x value to add to the point y Number y value to add to the point Source: phaser_geometry.js, line 618 Returns: point.add(x, y); &lt;static&gt; points_angle_between(pointA, pointB) Calculates the angle between two points and returns the result. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA first angle to calculate pointB second angle to calculate Source: phaser_geometry.js, line 314 Returns: Phaser.Point.angle(pointA, pointB) &lt;static&gt; points_ceil(point) Applies Math.ceil() to the x and y values of the point. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to change the values of Source: phaser_geometry.js, line 698 Returns: point.ceil(); &lt;static&gt; points_centroid(array) Returns a new point with the centroid of the list of points. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description array Array list of points to calculate the centroid from Source: phaser_geometry.js, line 472 Returns: Phaser.Point.centroid(array) &lt;static&gt; points_clamp(point, min, max) Clamps the point object values to be between the given minimum and maximum. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to clamp min Number the minimum value to clamp the point to max Number the maximum value to clamp the point to Source: phaser_geometry.js, line 488 Returns: point.clamp(min, max); &lt;static&gt; points_clamp_x(point, min, max) Clamp the point object x value to be between the given minimum and maximum. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to clamp min Number the minimum value to clamp the value to max Number the maximum value to lcmap the value to Source: phaser_geometry.js, line 508 Returns: point.clampX(min, max); &lt;static&gt; points_clamp_y(point, min, max) Clamp the point object y value to be between the given minimum and maximum. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to clamp min Number the minimum value to clamp the value to max Number the maximum value to lcmap the value to Source: phaser_geometry.js, line 528 Returns: point.clampY(min, max); &lt;static&gt; points_clone(point) Returns a new point with the same properties as the original point. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to clone Source: phaser_geometry.js, line 548 Returns: point.clone() &lt;static&gt; points_copy_from(source, target) Copies values from one point to another, overwriting the original values. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description source point to get the values from target point to copy the values to Source: phaser_geometry.js, line 564 Returns: target.copyFrom(source); &lt;static&gt; points_cross(pointA, pointB) Calculates the cross product of two points and returns the result. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA left-hand side pointB right-hand side Source: phaser_geometry.js, line 582 Returns: pointA.cross(pointB) &lt;static&gt; points_distance(pointA, pointB) Calculates the distance between two points and returns the result. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA first angle to calculate pointB second angle to calculate Source: phaser_geometry.js, line 332 Returns: Phaser.Point.distance(pointA, pointB) &lt;static&gt; points_divide(pointA, pointB) Divides the coordinates of two points and returns a new point with the result. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA first point to divide pointB second point to divide Source: phaser_geometry.js, line 350 Returns: Phaser.Point.divide(pointA, pointB) &lt;static&gt; points_divide_member(point, x, y) Divides the point values by the given x and y values. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to divide x Number x value to divide the point by y Number y value to divide the point by Source: phaser_geometry.js, line 658 Returns: point.divide(x, y); &lt;static&gt; points_dot(pointA, pointB) Calculates the dot product of two points and returns the result. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA left-hand side pointB right-hand side Source: phaser_geometry.js, line 600 Returns: pointA.dot(pointB) &lt;static&gt; points_equals(pointA, pointB) Returns true/false if one point has the same x/y values as another. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA first point to check pointB second point to check Source: phaser_geometry.js, line 368 Returns: Phaser.Point.equals(pointA, pointB) &lt;static&gt; points_floor(point) Applies Math.floor() to the x and y values of the point. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to change the values of Source: phaser_geometry.js, line 714 Returns: point.floor(); &lt;static&gt; points_get_magnitude(point) Returns the length of the point object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to get the magnitude of Source: phaser_geometry.js, line 730 Returns: point.getMagnitude() &lt;static&gt; points_get_magnitude_squared(point) Returns the length squared of the point object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to get the magnitude squared of Source: phaser_geometry.js, line 746 Returns: point.getMagnitudeSq() &lt;static&gt; points_interpolate(pointA, pointB, f) Interpolates the two points based on the percent value between 0 and 1. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA first point pointB second point f Number the level of interpolation between the two points Source: phaser_geometry.js, line 386 Returns: Phaser.Point.interpolate(pointA, pointB, f) &lt;static&gt; points_invert(point) Inverts the x and y values of the point. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to invert Source: phaser_geometry.js, line 762 Returns: point.invert(); &lt;static&gt; points_is_zero(point) Returns true/false if the point has the values 0,0. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to check Source: phaser_geometry.js, line 778 Returns: point.isZero() &lt;static&gt; points_limit(point, max) Alters the point so it's magnitude is no more than the given maximum value. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to change max Number the value to set the maximum to Source: phaser_geometry.js, line 794 Returns: point.limit(max); &lt;static&gt; points_multiply(pointA, pointB) Multiplies the coordinates of two points and returns a new point with the result. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA first point to multiply pointB second point to multiply Source: phaser_geometry.js, line 406 Returns: Phaser.Point.multiply(pointA, pointB) &lt;static&gt; points_multiply_member(point, x, y) Multiplies the point values by the given x and y values. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to multiply x Number x value to multiply the point by y Number y value to multiply the point by Source: phaser_geometry.js, line 678 Returns: point.multiply(x, y); &lt;static&gt; points_negate(pointA) Creates a new point with negative values of the original point. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA point to get the values from Source: phaser_geometry.js, line 424 Returns: Phaser.Point.negative(pointA) &lt;static&gt; points_normalize(pointA) Returns a new point of the normalized values of the original. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA point to normalize Source: phaser_geometry.js, line 440 Returns: Phaser.Point.normalize(pointA) &lt;static&gt; points_perpendicular(pointA) Returns a new point with the perpendicular vector to the original point. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA point to get the vector from Source: phaser_geometry.js, line 456 Returns: Phaser.Point.perp(pointA) &lt;static&gt; points_set_to_polar(point, degrees, radius) Sets the x and y values of hte point based on the given polar coordinate. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to change the values of degrees Number degrees of the polar coordinate radius Number radius of the polar coordinate Source: phaser_geometry.js, line 812 Returns: point.setToPolar(degrees, radius, true); &lt;static&gt; points_subtract(pointA, pointB) Subtracts the coordinates of two points and returns a new point with the result. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description pointA first point to subtract pointB second point to subtract Source: phaser_geometry.js, line 296 Returns: Phaser.Point.subtract(pointA, pointB) &lt;static&gt; points_subtract_member(point, x, y) Subtracts the given x and y values from the point. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description point point to subtract values from x Number x value to subtract from the point y Number y value to subtract from the point Source: phaser_geometry.js, line 638 Returns: point.subtract(x, y); × Search results Close "},"Pointer.html":{"id":"Pointer.html","title":"Namespace: Pointer","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Pointer Pointer Source: phaser_input.js, line 875 Methods &lt;static&gt; pointer_get_device_buttons_field(object, field) Returns the chosen button from the mouse. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object pointer to get the buttons from field which button to return Source: phaser_input.js, line 879 Returns: object.field × Search results Close "},"Random.html":{"id":"Random.html","title":"Namespace: Random","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Random Random Source: phaser_utility.js, line 505 Methods &lt;static&gt; random_angle() Returns a random angle between -180 and 180. Check out Phaser documentation for a more in depth explanation. Source: phaser_utility.js, line 532 Returns: game.rnd.angle() &lt;static&gt; random_boolean() Randomly returns true or false. Check out Phaser documentation for a more in depth explanation. Source: phaser_utility.js, line 624 Returns: game.rnd.pick([true, false]) &lt;static&gt; random_pick(array) Returns a random item from the list. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description array list to pick from Source: phaser_utility.js, line 546 Returns: game.rnd.pick(array) &lt;static&gt; random_pick_weighted(array) Returns a random item from the list, favoring items at the beginning. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description array list to pick from Source: phaser_utility.js, line 562 Returns: game.rnd.weightedPick(array) &lt;static&gt; random_real() Returns a random real number between 0 and 2^32. Check out Phaser documentation for a more in depth explanation. Source: phaser_utility.js, line 578 Returns: game.rnd.real() &lt;static&gt; random_real_in_range(min, max) Returns a random number between the given range, inclusive. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description min Number the minimum value in the range max Number the maximum value in the range Source: phaser_utility.js, line 592 Returns: game.rnd.realInRange(min, max) &lt;static&gt; random_sign() Returns a random sign to be used with multiplication. Returns -1 or +1. Check out Phaser documentation for a more in depth explanation. Source: phaser_utility.js, line 610 Returns: game.rnd.sign() × Search results Close "},"Rectangle.html":{"id":"Rectangle.html","title":"Namespace: Rectangle","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Rectangle Rectangle Source: phaser_geometry.js, line 1 Methods &lt;static&gt; rectangle_clone(rectangle) Returns a new rectangle with the same x, y, width, and height properties of the original. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description rectangle rectangle to clone Source: phaser_geometry.js, line 167 Returns: rectangle.clone() &lt;static&gt; rectangle_contains(rectangle, x, y) Returns true/false if the rectangle contains the given coordinates. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description rectangle rectangle to check x Number x coordinate to check y Number y coordinate to check Source: phaser_geometry.js, line 130 Returns: Phaser.Rectangle.contains(rectangle, x, y) &lt;static&gt; rectangle_contains_point(rectangle, point) Returns true/false if the rectangle contains the point. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description rectangle rectangle to check point point to check Source: phaser_geometry.js, line 112 Returns: Phaser.Rectangle.containsPoint(rectangle, point) &lt;static&gt; rectangle_contains_rect(rectangle_a, rectangle_b) Returns true/false if one rectangle is fulling contained within another. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description rectangle_a the first rectangle to check rectangle_b the second rectangle to check Source: phaser_geometry.js, line 149 Returns: Phaser.Rectangle.containsRect(rectangle_a, rectangle_b) &lt;static&gt; rectangle_create(x, y, width, height) Creates a rectangle with the given properties. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number x coordinate for the new rectangle y Number y coordinate for the new rectangle width Number width of the rectangle height Number height of the rectangle Source: phaser_geometry.js, line 5 Returns: new Phaser.Rectangle(x, y, width, height) &lt;static&gt; rectangle_get_numeric_field(object, field) Returns the chosen numeric field value of the rectangle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to get values from field the field to get values of Source: phaser_geometry.js, line 45 Returns: object.field &lt;static&gt; rectangle_get_point_field(object, field) Returns the chosen point field value of the rectangle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to get values from field the field to get values of Source: phaser_geometry.js, line 57 Returns: object.field &lt;static&gt; rectangle_intersects(rectA, rectB) Returns true/false if the two rectangles intersect. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description rectA first rectangle to check rectB second rectangle to check Source: phaser_geometry.js, line 27 Returns: Phaser.Rectangle.intersects(rectA, rectB) &lt;static&gt; rectangle_random(rectangle) Returns a random x/y coordinate point from the rectangle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description rectangle rectangle to get values from Source: phaser_geometry.js, line 184 Returns: rectangle.random() &lt;static&gt; rectangle_set_numeric_field(object, field, value) Assign the chosen numeric field of the rectangle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set the value for field the field to set value Number value to set the field to Source: phaser_geometry.js, line 77 Returns: object.field = value; &lt;static&gt; rectangle_set_point_field(object, field, point) Assign the chosen point field of the rectangle. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set the point for field the field to set point point to set the field to Source: phaser_geometry.js, line 97 Returns: object.field.copyFrom(point); × Search results Close "},"Setup.html":{"id":"Setup.html","title":"Namespace: Setup","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Setup Setup Source: phaser_physics.js, line 2 Methods &lt;static&gt; enable_arcade_physics_for_object_vi(object) Adds a physics body to the object. This allows the object to collide with other physics bodies and use other physics functionality. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to enable physics on Source: phaser_physics.js, line 85 Returns: game.physics.arcade.enable(object); &lt;static&gt; enable_body_group_vi(group) Enables physics body for all objects in the group. This allows the objects to collide with other physics bodies and use other physics functionality. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description group group to enable physics on Source: phaser_physics.js, line 52 Returns: group.enableBody = true; &lt;static&gt; start_arcade_physics() Enables the Phaser Arcade phyiscs to be used in the game. Check out Phaser documentation for a more in depth explanation. Source: phaser_physics.js, line 21 Returns: game.physics.startSystem(Phaser.Physics.ARCADE); × Search results Close "},"Sound.html":{"id":"Sound.html","title":"Namespace: Sound","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Sound Sound Source: phaser_sound.js, line 1 Methods &lt;static&gt; add_sound(tag, volume, looping) Returns a new sound object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description tag String the tag of the sound to add volume Number volume to play the sound at looping Boolean whether or not to loop the sound when it's played Source: phaser_sound.js, line 37 Returns: game.add.audio(tag, volume, looping) &lt;static&gt; get_sound_boolean_member(object, element) Returns the chosen boolean field value of the sound. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to get values from element the element to get values of Source: phaser_sound.js, line 113 Returns: object.element &lt;static&gt; get_sound_numeric_member(object, element) Returns the chosen numeric field value of the sound. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to get values from element the element to get values of Source: phaser_sound.js, line 125 Returns: object.element &lt;static&gt; get_sound_string_member(object, element) Returns the chosen string field value of the sound. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to get values from element the element to get values of Source: phaser_sound.js, line 137 Returns: object.element &lt;static&gt; load_sound(tag, source) Creates a sound with the given tag by loading it into the audio queue. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description tag String tag to name the sound source String file path of the sound Source: phaser_sound.js, line 5 Returns: game.load.audio(tag, source); &lt;static&gt; set_sound_boolean_member(element, object, value) Assigns the chosen boolean field for the sound. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description element the field to set object sound to assign values for value value to set the field to Source: phaser_sound.js, line 85 Returns: object.element = value; &lt;static&gt; set_sound_numeric_member(element, object, value) Assigns the chosen numeric field for the sound. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description element the field to set object sound to assign values for value value to set the field to Source: phaser_sound.js, line 98 Returns: object.element = value; &lt;static&gt; sound_fade_in(sound_object, duration, loop) Starts playing the sound at a volume of 0, and reaches the maximum volume for the sound over the given time, with the option to loop. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sound_object sound to play duration Number the time it takes for the sound to reach maximum volume loop Boolean whether or not the sound should loop Source: phaser_sound.js, line 151 Returns: sound_object.fadeIn(duration, loop); &lt;static&gt; sound_fade_out(sound_object, duration) Makes the sound go from it's current volume to a volume of 0 over the given time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sound_object sound to stop duration Number the time it takes for the sound to reach 0 Source: phaser_sound.js, line 171 Returns: sound_object.fadeOut(duration); &lt;static&gt; sound_fade_to(sound_object, duration, volume) Makes the sound go from it's current volume to the given volume over the given time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sound_object sound to change duration Number the time it takes for the sound to reach the new volume volume Number the volume to change the sound to Source: phaser_sound.js, line 189 Returns: sound_object.fadeTo(duration, volume); &lt;static&gt; sound_loop_full(sound_object, volume) Loops the entire sound at the given volume. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sound_object sound to loop volume Number volume to play the sound at Source: phaser_sound.js, line 209 Returns: sound_object.loopFull(volume); &lt;static&gt; sound_pause(sound_object) Pause the sound. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sound_object sound to pause Source: phaser_sound.js, line 243 Returns: sound_object.pause(); &lt;static&gt; sound_play(sound_object, position, volume, loop, restart) Play the sound with the given properties. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sound_object sound to play position Number position to play the sound from volume Number volume to play the sound at loop Boolean whether or not the sound should loop restart Boolean option to force the sound to restart from the beginning Source: phaser_sound.js, line 275 Returns: sound_object.play('', position, volume, loop, restart); &lt;static&gt; sound_restart(sound_object, position, volume, loop) Restarts the sound with the given properties. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sound_object sound to restart position Number the starting position to play the sound from volume Number the volume to play the sound at loop Boolean whether or not the sound should loop Source: phaser_sound.js, line 300 Returns: sound_object.play('', position, volume loop); &lt;static&gt; sound_resume(sound_object) Resume the sound. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sound_object sound to resume Source: phaser_sound.js, line 259 Returns: sound_object.resume(); &lt;static&gt; sound_stop(sound_object) Stop the sound playing. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description sound_object sound to stop Source: phaser_sound.js, line 227 Returns: sound_object.stop(); &lt;static&gt; stop_pause_resume_sounds(option) Stop, pause, or remove all sounds in the game. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description option which option to do Source: phaser_sound.js, line 69 Returns: game.sound.optionAll(); × Search results Close "},"Sprite_Image.html":{"id":"Sprite_Image.html","title":"Namespace: Sprite/Image","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Sprite/Image Sprite/Image Source: phaser_objects.js, line 1 Methods &lt;static&gt; add_child_at_vi(object, child, index) Adds a child to the given object at the given index. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object the object to add a child to child the child to add to the object index Number the index to add the child to Source: phaser_objects.js, line 221 Returns: object.addChildAt(child, index); &lt;static&gt; add_child_vi(object, child) Adds a child to the given object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object the object to add a child to child the child to add to the object Source: phaser_objects.js, line 182 Returns: object.addChild(child); &lt;static&gt; add_image(x, y, tag) Create a sprite based on an image. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number x position of the sprite y Number y position of the sprite tag String the tag of the image to use for the sprite Source: phaser_objects.js, line 67 Returns: game.add.sprite(x, y, tag); &lt;static&gt; addspritewithatlas(tag, source, xml) Create an atlas image to be used in the game. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description tag String the tag that defines the image source String the file path of the image xml String the file path of the xml file Source: phaser_objects.js, line 25 Returns: game.load.atlasXML(tag, source, xml); &lt;static&gt; align_in(object, container, position, offset_x, offset_y) Align an object inside of another object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to align container object to align to position Number position to justify the alignment to offset_x Number horizontal adjustment of the alignment offset_y Number vertical adjustment of the alignment Source: phaser_objects.js, line 241 Returns: object.alignIn(container, Phaser.position, offset_x, offset_y); &lt;static&gt; align_to(object, container, position, offset_x, offset_y) Align an object to the side of another object. Check out Phaser documentation for a more in depth explanation. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to align container object to align to position Number position to justify the alignment to offset_x Number horizontal adjustment of the alignment offset_y Number vertical adjustment of the alignment Source: phaser_objects.js, line 265 Returns: object.alignTo(container, Phaser.position, offset_x, offset_y); &lt;static&gt; bring_to_top(object) Render an object on top of all other objects. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to render Source: phaser_objects.js, line 292 Returns: object.bringToTop(); &lt;static&gt; check_world_bounds(object, bool) If true, the game checks every frame to see if an object is within the world bounds, and returns a boolean with the result. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check bool Boolean enables/disables checking world bounds Source: phaser_objects.js, line 308 Returns: object.checkWorldBounds = bool; &lt;static&gt; clear_cropping(object) Clear the cropping on an object's image. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object whose image is cropped Source: phaser_objects.js, line 381 Returns: object.crop(); &lt;static&gt; clear_scale_min_max(object) Clears all scale constraints set on the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to clear scale constraints from Source: phaser_objects.js, line 806 Returns: object.setScaleMinMax(); &lt;static&gt; contains_vi(object, child) Checks if an object contains the given child. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check child child to check Source: phaser_objects.js, line 345 Returns: object.contains(child); &lt;static&gt; create_image(tag, source) Create an image to be used in the game. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description tag String the tag that defines the image source String the file path of the image Source: phaser_objects.js, line 6 Returns: game.load.image(tag, source); &lt;static&gt; create_sprite_sheet(tag, source, width, height) Create a sprite sheet from an image. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description tag String the tag that defines the image source String the file path of the image width Number the width of each frame height Number the height of each frame Source: phaser_objects.js, line 141 Returns: game.load.spritesheet(tag, source, width, height); &lt;static&gt; crop(object, rectangle) Crop the image of an object to the given rectangular bounds. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object whose image is getting cropped rectangle Phaser.Rectangle the rectangle bounds and properites to use for the crop Source: phaser_objects.js, line 363 Returns: object.crop(rectangle); &lt;static&gt; destroy_sprite(object, bool) Destroy the given sprite object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to destroy bool Boolean whether or not the sprite's children should also be destroyed Source: phaser_objects.js, line 397 Returns: object.destroy(bool); &lt;static&gt; get_child_at_vi(object, index) Get the child at the given index. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to get the child from index Number index the child is located at Source: phaser_objects.js, line 434 Returns: object.getChildAt(index); &lt;static&gt; get_child_index_vi(object, child) Get the index of the given child. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to get the child from child child to get the index from Source: phaser_objects.js, line 471 Returns: object.getChildIndex(child); &lt;static&gt; imagesubtextureatlas(x, y, tag, id) Create a sprite based on an atlas image. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number x position of the sprite y Number y position of the sprite tag String the tag of the image to use for the sprite id String the id of the xml texture to use for the sprite Source: phaser_objects.js, line 45 Returns: game.add.sprite(x, y, tag, id); &lt;static&gt; load_texture(object, tag) Changes the image of a sprite object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object whose image is getting changed tag String the tag of the texture to change the image to Source: phaser_objects.js, line 489 Returns: object.loadTexture(tag); &lt;static&gt; move_down(object) Moves the object down one layer in the display list. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to render Source: phaser_objects.js, line 507 Returns: object.moveDown(); &lt;static&gt; move_up(object) Moves the object up one layer in the display list. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to render Source: phaser_objects.js, line 523 Returns: object.moveUp(); &lt;static&gt; out_of_bounds_faint(object, boolean) If true, the object gets deleted if it leaves the world bounds. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object that gets deleted boolean Boolean sets the action to true or false Source: phaser_objects.js, line 566 Returns: object.outOfBoundsFaint = boolean; &lt;static&gt; remove_child_at_vi(object, index) Removes the child at the given index from the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to remove the child from index index of the child to remove from the object Source: phaser_objects.js, line 643 Returns: object.removeChildAt(index); &lt;static&gt; remove_child_vi(object, child) Removes the given child from the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to remove the child from child child to remove from the object Source: phaser_objects.js, line 625 Returns: object.removeChild(child); &lt;static&gt; remove_children_vi() Removes all children from the object. Check out Phaser documentation for a more in depth explanation. Source: phaser_objects.js, line 661 Returns: object.removeChildren(); &lt;static&gt; send_to_back(object) Render an object below all other objects. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to render Source: phaser_objects.js, line 713 Returns: object.sendToBack(); &lt;static&gt; set_child_index_vi(object, child, index) Sets the position of the child in the object's list of children. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object that contains the child child child to change the position of index Number index to set the child's position to Source: phaser_objects.js, line 744 Returns: object.setChildIndex(child, index); &lt;static&gt; set_scale_min_max(object, minX, minY, maxX, maxY) Sets the limits for how the object will scale based on it's parent. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set the scale constraints for minX Number the minimum horizontal scale the Game Object can scale down to minY Number the minimum vertical scale the Game Object can scale down to maxX Number the maximum horizontal scale the Game Object can scale down to maxY Number the maximum vertical scale the Game Object can scale down to Source: phaser_objects.js, line 782 Returns: object.setScaleMinMax(minX, minY, maxX, maxY); &lt;static&gt; set_sprite_frame(object, frame) Sets the texture frame for the object to use for rendering. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to set the frame for frame frame to set the texture to Source: phaser_objects.js, line 764 Returns: object.setFrame(frame); &lt;static&gt; swap_children(parent, child, child2) Swaps the position of the two children in the object's list. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description parent parent of the children who are being swapped child to be swapped with child2 child2 to be swapped with cihld Source: phaser_objects.js, line 840 Returns: parent.swapChildren(child, child2); × Search results Close "},"Startup.html":{"id":"Startup.html","title":"Namespace: Startup","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Startup Startup Source: phaser_game.js, line 1 Methods &lt;static&gt; Blockly.JavaScript['phaser_simple_init'](width, height) The main controller for the entire Phaser game. The functions run in order from top to bottom, with preload and create running once, and update running as a loop until the game ends. Check the game engine documentation for more details. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description width Number The width of the game world height Number The height of the game world Source: phaser_game.js, line 19 Returns: var game = new Phaser.Game([width], [height], Phaser.AUTO, '', {preload: preload, create: create, update: update}); &lt;static&gt; center_and_stretch() Stretch the stuff Check out Phaser documentation for a more in depth explanation. Source: phaser_game.js, line 53 Returns: game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL; this.scale.pageAlignHorizontally = true; this.scale.pageAlignVertically = true; this.scale.updateLayout( true ); &lt;static&gt; start_phaser_for_states(width, height) The main controller for the entire Phaser game. Starts an instance of phaser without using preload, create, and update. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description width Number The width of the game world height Number The height of the game world Source: phaser_game.js, line 36 Returns: var game = new Phaser.Game(${number_width}, ${number_height}, Phaser.AUTO, ''); × Search results Close "},"States.html":{"id":"States.html","title":"Namespace: States","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: States States Source: phaser_game.js, line 245 Methods &lt;static&gt; statemanager_add_state(name, key) Adds a state to the game with the given name and key. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description name String name of the new state key tag to use for the state Source: phaser_game.js, line 249 Returns: game.state.add(key, name); &lt;static&gt; statemanager_check_state(key) Returns true or false if the state with the given tag is valid. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description key String tag of the state to check Source: phaser_game.js, line 313 Returns: game.state.checkState(key) &lt;static&gt; statemanager_get_current_state() Returns the state that is currently running. Check out Phaser documentation for a more in depth explanation. Source: phaser_game.js, line 285 Returns: game.state.getCurrentState() &lt;static&gt; statemanager_restart_state() Restarts the current state. Check out Phaser documentation for a more in depth explanation. Source: phaser_game.js, line 299 Returns: game.state.restart(); &lt;static&gt; statemanager_start_state(tag) Start the state with the given tag. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description tag tag of the state to start Source: phaser_game.js, line 268 Returns: game.start.state(tag); × Search results Close "},"Time.html":{"id":"Time.html","title":"Namespace: Time","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Time Time Source: phaser_game.js, line 330 Methods &lt;static&gt; create_timer(autoDestroy) Creates and returns a new timer. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description autoDestroy Boolean whether or not the timer should automatically destroy when it's done Source: phaser_game.js, line 465 Returns: game.time.create(autoDestroy) &lt;static&gt; delta_time_milliseconds() Returns the physics update delta in milliseconds. Check out Phaser documentation for a more in depth explanation. Source: phaser_game.js, line 383 Returns: game.time.physicsElapsedMS &lt;static&gt; delta_time_seconds() Returns the physics update delta in seconds. Check out Phaser documentation for a more in depth explanation. Source: phaser_game.js, line 369 Returns: game.time.physicsElapsed &lt;static&gt; get_time_numeric_member(field) Returns the chosen numeric field value of the game timer. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to get Source: phaser_game.js, line 335 Returns: game.time.field &lt;static&gt; get_timer_boolean_member(field, timer) Returns the chosen boolean field value of the timer. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to get timer timer to get the values from Source: phaser_game.js, line 410 Returns: timer.field &lt;static&gt; get_timer_numeric_member(field, timer) Returns the chosen numeric field value of the timer. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to get timer timer to get the values from Source: phaser_game.js, line 398 Returns: timer.field &lt;static&gt; set_time_numeric_member(field, value) Assigns the chosen numeric field for the game timer. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to set value value to set the field to Source: phaser_game.js, line 351 Returns: game.time.field = value; &lt;static&gt; set_timer_boolean_member(field, timer, value) Assigns the chosen boolean field for the timer. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to set timer timer to assign values for value value to set the field to Source: phaser_game.js, line 430 Returns: timer.field = value; &lt;static&gt; set_timer_numeric_member(field, timer, value) Assigns the chosen numeric field for the timer. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description field the value to set timer timer to assign values for value value to set the field to Source: phaser_game.js, line 443 Returns: timer.field = value; &lt;static&gt; start_timer(delay, timer) Start the chosen timer after the given amount of time. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description delay Number how long to wait before starting the timer timer timer to start Source: phaser_game.js, line 497 Returns: timer.start(delay); &lt;static&gt; time_constants(constant) Returns the chosen constant time value. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description constant which time value to return Source: phaser_game.js, line 481 Returns: constant &lt;static&gt; timer_add_event_complex(delay, callback, timer, arguments) Adds an event to the timer, to be called after the given amount of time, once the timer has started running. The delay applies only after the timer has started. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description delay Number the number of milliseconds before the timer function is called callback the function to call timer timer to add the function call event to arguments (optional) arguments to use in the function that gets called Source: phaser_game.js, line 528 Returns: timer.add(delay, callback, undefined, arguments[if any]); &lt;static&gt; timer_destroy(timer) Destroy the timer and stops any future related events from happening. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description timer timer to destroy Source: phaser_game.js, line 632 Returns: timer.destroy(); &lt;static&gt; timer_loop_event_complex(delay, repeatCount, callback, timer, arguments) Adds an event to the timer, to be called continuously after the given amount of time for the given number of times, once the timer has started running. The delay applies only after the timer has started. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description delay Number the number of milliseconds before the timer function is called repeatCount Number the number of times to call the event callback the function to call timer timer to add the function call event to arguments (optional) arguments to use in the function that gets called Source: phaser_game.js, line 606 Returns: timer.add(delay, repeatCount, callback, arguments[if any]); &lt;static&gt; timer_loop_event_complex(delay, callback, timer, arguments) Adds an event to the timer, to be called continuously after the given amount of time, once the timer has started running. The delay applies only after the timer has started. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description delay Number the number of milliseconds before the timer function is called callback the function to call timer timer to add the function call event to arguments (optional) arguments to use in the function that gets called Source: phaser_game.js, line 567 Returns: timer.add(delay, callback, arguments[if any]); &lt;static&gt; timer_pause(timer) Pause the timer and all future related events. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description timer timer to pause Source: phaser_game.js, line 648 Returns: timer.pause(); &lt;static&gt; timer_resume(timer) Resumes the timer and all future related events. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description timer timer to resume Source: phaser_game.js, line 664 Returns: timer.resume(); &lt;static&gt; timer_set_on_complete_callback(timer, callback) Call the given function once the timer has completed and has no other events to call. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description timer timer to use callback function to call Source: phaser_game.js, line 710 Returns: timer.onComplete.add(callback); &lt;static&gt; timer_stop(timer, clearEvents) Stops the timer, with the option to clear the related events. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description timer timer to stop clearEvents Boolean option to keep or remove events related to the timer Source: phaser_game.js, line 680 Returns: timer.stop(clearEvents); × Search results Close "},"Util.html":{"id":"Util.html","title":"Namespace: Util","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: Util Util Source: phaser_physics.js, line 358 Methods &lt;static&gt; physics_distance_between(source, target) Returns the distance between the two objects, based on their x/y coordinates. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description source object to check from target object to check to Source: phaser_physics.js, line 398 Returns: game.physics.arcade.distanceBetween(source, target); &lt;static&gt; physics_distance_to_location(object, x, y) Returns the distance between an object and an x/y location in the game. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description object object to check from x Number x location to check y Number y location to check Source: phaser_physics.js, line 434 Returns: game.physics.aracde.distanceToXY(object, x, y); &lt;static&gt; physics_distance_to_pointer(source, pointer) Returns the distance between an object and the mouse pointer. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description source object to check from pointer mouse pointer to check to Source: phaser_physics.js, line 416 Returns: game.physics.arcade.distanceToPointer(source, pointer); × Search results Close "},"World.html":{"id":"World.html","title":"Namespace: World","body":" DragonDrop Namespaces AnimationBodyCameraCircleCollisionDebugDeviceButtonDynamicsGameObjectGraphicsGroupsInputHandlerKeyboardMathMouseParticlesPhaserListPhaserTextPointPointerRandomRectangleSetupSoundSprite/ImageStartupStatesTimeUtilWorld Namespace: World World Source: phaser_game.js, line 70 Methods &lt;static&gt; get_game_pause() Returns whether or not the game is paused. Check out Phaser documentation for a more in depth explanation. Source: phaser_game.js, line 231 Returns: game.paused &lt;static&gt; get_world_property(property) Returns the property of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description property property to get values from Source: phaser_game.js, line 74 Returns: game.world.property &lt;static&gt; set_game_pause(paused) Pauses/unpauses the game. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description paused Boolean sets the game paused to true or false Source: phaser_game.js, line 214 Returns: game.paused = paused; &lt;static&gt; set_scale_vi(x, y, object) Sets the scale of the object. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number amount to scale the object in the x direction y Number amount to scale the object in the y direction object object to scale Source: phaser_game.js, line 139 Returns: object.scale.setTo(x, y); &lt;static&gt; set_world_bounds(x, y, w, h) Sets the top-left coordinates and size/physical bounds of the game world. Check out Phaser documentation for a more in depth explanation. Parameters: Name Type Description x Number the x coordinate of the top-left corner of the world y Number the y coordinate of the top-left corner of the world w Number the width of the game world h Number the height of the game world Source: phaser_game.js, line 90 Returns: game.world.setBounds(x, y, w, h); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
